!<arch>
__.PKGDEF       0           0     0     644     23208     `
go object darwin 386 go1.6 X:none

$$
package ecdsa
	import crypto "crypto"
	import io "io"
	import aes "crypto/aes"
	import cipher "crypto/cipher"
	import elliptic "crypto/elliptic"
	import big "math/big"
	import sha512 "crypto/sha512"
	import asn1 "encoding/asn1"
	type @"math/big".Word uintptr
	type @"math/big".divisor struct { @"math/big".bbb @"math/big".nat; @"math/big".nbits int; @"math/big".ndigits int }
	import rand "math/rand" // indirect
	type @"math/rand".Source interface { Int63() (? int64); Seed(@"math/rand".seed int64) }
	type @"math/rand".Rand struct { @"math/rand".src @"math/rand".Source }
	func (@"math/rand".rÂ·2 *@"math/rand".Rand "esc:0x9") ExpFloat64 () (? float64)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand "esc:0x9") Float32 () (? float32)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand "esc:0x9") Float64 () (? float64)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand "esc:0x9") Int () (? int)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand "esc:0x9") Int31 () (? int32)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand "esc:0x9") Int31n (@"math/rand".nÂ·3 int32) (? int32)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand "esc:0x9") Int63 () (? int64)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand "esc:0x9") Int63n (@"math/rand".nÂ·3 int64) (? int64)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand "esc:0x9") Intn (@"math/rand".nÂ·3 int) (? int)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand "esc:0x9") NormFloat64 () (? float64)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand "esc:0x9") Perm (@"math/rand".nÂ·3 int) (? []int)
	func (@"math/rand".rÂ·3 *@"math/rand".Rand "esc:0x9") Read (@"math/rand".pÂ·4 []byte "esc:0x1") (@"math/rand".nÂ·1 int, @"math/rand".errÂ·2 error)
	func (@"math/rand".rÂ·1 *@"math/rand".Rand "esc:0x9") Seed (@"math/rand".seedÂ·2 int64)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand "esc:0x9") Uint32 () (? uint32)
	type @"io".ByteScanner interface { ReadByte() (@"io".c byte, @"io".err error); UnreadByte() (? error) }
	type @"math/big".nat []@"math/big".Word
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".add (@"math/big".xÂ·3 @"math/big".nat, @"math/big".yÂ·4 @"math/big".nat) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x12") @"math/big".and (@"math/big".xÂ·3 @"math/big".nat "esc:0x1", @"math/big".yÂ·4 @"math/big".nat "esc:0x1") (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x12") @"math/big".andNot (@"math/big".xÂ·3 @"math/big".nat "esc:0x9", @"math/big".yÂ·4 @"math/big".nat "esc:0x1") (? @"math/big".nat)
	func (@"math/big".xÂ·2 @"math/big".nat "esc:0x1") @"math/big".bit (@"math/big".iÂ·3 uint) (? uint) { var @"math/big".jÂ·4 uint; ; @"math/big".jÂ·4 = @"math/big".iÂ·3 / uint(0x20); if @"math/big".jÂ·4 >= uint(len(@"math/big".xÂ·2)) { return uint(0x0) }; return uint(@"math/big".xÂ·2[@"math/big".jÂ·4] >> (@"math/big".iÂ·3 % uint(0x20)) & @"math/big".Word(0x1)) }
	func (@"math/big".xÂ·2 @"math/big".nat "esc:0x1") @"math/big".bitLen () (? int)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x1") @"math/big".bytes (@"math/big".bufÂ·3 []byte "esc:0x1") (@"math/big".iÂ·1 int)
	func (@"math/big".zÂ·1 @"math/big".nat "esc:0x1") @"math/big".clear ()
	func (@"math/big".xÂ·2 @"math/big".nat "esc:0x1") @"math/big".cmp (@"math/big".yÂ·3 @"math/big".nat "esc:0x1") (@"math/big".rÂ·1 int)
	func (@"math/big".qÂ·1 @"math/big".nat) @"math/big".convertWords (@"math/big".sÂ·2 []byte "esc:0x1", @"math/big".bÂ·3 @"math/big".Word, @"math/big".ndigitsÂ·4 int, @"math/big".bbÂ·5 @"math/big".Word, @"math/big".tableÂ·6 []@"math/big".divisor "esc:0x9")
	func (@"math/big".zÂ·3 @"math/big".nat) @"math/big".div (@"math/big".z2Â·4 @"math/big".nat, @"math/big".uÂ·5 @"math/big".nat, @"math/big".vÂ·6 @"math/big".nat) (@"math/big".qÂ·1 @"math/big".nat, @"math/big".rÂ·2 @"math/big".nat)
	func (@"math/big".zÂ·3 @"math/big".nat "esc:0x12") @"math/big".divLarge (@"math/big".uÂ·4 @"math/big".nat, @"math/big".uInÂ·5 @"math/big".nat, @"math/big".vÂ·6 @"math/big".nat) (@"math/big".qÂ·1 @"math/big".nat, @"math/big".rÂ·2 @"math/big".nat)
	func (@"math/big".zÂ·3 @"math/big".nat) @"math/big".divW (@"math/big".xÂ·4 @"math/big".nat, @"math/big".yÂ·5 @"math/big".Word) (@"math/big".qÂ·1 @"math/big".nat, @"math/big".rÂ·2 @"math/big".Word)
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".expNN (@"math/big".xÂ·3 @"math/big".nat, @"math/big".yÂ·4 @"math/big".nat "esc:0x1", @"math/big".mÂ·5 @"math/big".nat) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".expNNMontgomery (@"math/big".xÂ·3 @"math/big".nat, @"math/big".yÂ·4 @"math/big".nat "esc:0x1", @"math/big".mÂ·5 @"math/big".nat) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".expNNWindowed (@"math/big".xÂ·3 @"math/big".nat, @"math/big".yÂ·4 @"math/big".nat "esc:0x1", @"math/big".mÂ·5 @"math/big".nat) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".expWW (@"math/big".xÂ·3 @"math/big".Word, @"math/big".yÂ·4 @"math/big".Word) (? @"math/big".nat)
	func (@"math/big".xÂ·2 @"math/big".nat "esc:0x9") @"math/big".itoa (@"math/big".negÂ·3 bool, @"math/big".baseÂ·4 int) (? []byte)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x12") @"math/big".make (@"math/big".nÂ·3 int) (? @"math/big".nat)
	func (@"math/big".xÂ·2 @"math/big".nat) @"math/big".modW (@"math/big".dÂ·3 @"math/big".Word) (@"math/big".rÂ·1 @"math/big".Word)
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".montgomery (@"math/big".xÂ·3 @"math/big".nat, @"math/big".yÂ·4 @"math/big".nat "esc:0x1", @"math/big".mÂ·5 @"math/big".nat, @"math/big".kÂ·6 @"math/big".Word, @"math/big".nÂ·7 int) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".mul (@"math/big".xÂ·3 @"math/big".nat, @"math/big".yÂ·4 @"math/big".nat) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".mulAddWW (@"math/big".xÂ·3 @"math/big".nat, @"math/big".yÂ·4 @"math/big".Word, @"math/big".rÂ·5 @"math/big".Word) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".mulRange (@"math/big".aÂ·3 uint64, @"math/big".bÂ·4 uint64) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x12") @"math/big".norm () (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x12") @"math/big".or (@"math/big".xÂ·3 @"math/big".nat "esc:0x9", @"math/big".yÂ·4 @"math/big".nat "esc:0x9") (? @"math/big".nat)
	func (@"math/big".nÂ·2 @"math/big".nat) @"math/big".probablyPrime (@"math/big".repsÂ·3 int) (? bool)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x12") @"math/big".random (@"math/big".randÂ·3 *@"math/rand".Rand "esc:0x9", @"math/big".limitÂ·4 @"math/big".nat "esc:0x1", @"math/big".nÂ·5 int) (? @"math/big".nat)
	func (@"math/big".zÂ·5 @"math/big".nat) @"math/big".scan (@"math/big".rÂ·6 @"io".ByteScanner, @"math/big".baseÂ·7 int, @"math/big".fracOkÂ·8 bool) (@"math/big".resÂ·1 @"math/big".nat, @"math/big".bÂ·2 int, @"math/big".countÂ·3 int, @"math/big".errÂ·4 error)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x12") @"math/big".set (@"math/big".xÂ·3 @"math/big".nat "esc:0x9") (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x12") @"math/big".setBit (@"math/big".xÂ·3 @"math/big".nat "esc:0x9", @"math/big".iÂ·4 uint, @"math/big".bÂ·5 uint) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x12") @"math/big".setBytes (@"math/big".bufÂ·3 []byte "esc:0x1") (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x12") @"math/big".setUint64 (@"math/big".xÂ·3 uint64) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x12") @"math/big".setWord (@"math/big".xÂ·3 @"math/big".Word) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".shl (@"math/big".xÂ·3 @"math/big".nat, @"math/big".sÂ·4 uint) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".shr (@"math/big".xÂ·3 @"math/big".nat, @"math/big".sÂ·4 uint) (? @"math/big".nat)
	func (@"math/big".xÂ·2 @"math/big".nat "esc:0x1") @"math/big".sticky (@"math/big".iÂ·3 uint) (? uint)
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".sub (@"math/big".xÂ·3 @"math/big".nat, @"math/big".yÂ·4 @"math/big".nat) (? @"math/big".nat)
	func (@"math/big".xÂ·2 @"math/big".nat "esc:0x1") @"math/big".trailingZeroBits () (? uint)
	func (@"math/big".xÂ·2 @"math/big".nat "esc:0x9") @"math/big".utoa (@"math/big".baseÂ·3 int) (? []byte)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x12") @"math/big".xor (@"math/big".xÂ·3 @"math/big".nat "esc:0x9", @"math/big".yÂ·4 @"math/big".nat "esc:0x9") (? @"math/big".nat)
	import fmt "fmt" // indirect
	type @"fmt".State interface { Flag(@"fmt".c int) (? bool); Precision() (@"fmt".prec int, @"fmt".ok bool); Width() (@"fmt".wid int, @"fmt".ok bool); Write(@"fmt".b []byte) (@"fmt".ret int, @"fmt".err error) }
	type @"fmt".ScanState interface { Read(@"fmt".buf []byte) (@"fmt".n int, @"fmt".err error); ReadRune() (@"fmt".r rune, @"fmt".size int, @"fmt".err error); SkipSpace(); Token(@"fmt".skipSpace bool, @"fmt".f func(? rune) (? bool)) (@"fmt".token []byte, @"fmt".err error); UnreadRune() (? error); Width() (@"fmt".wid int, @"fmt".ok bool) }
	type @"math/big".Int struct { @"math/big".neg bool; @"math/big".abs @"math/big".nat }
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x1a") Abs (@"math/big".xÂ·3 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x1a") Add (@"math/big".xÂ·3 *@"math/big".Int "esc:0x9", @"math/big".yÂ·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x1a") And (@"math/big".xÂ·3 *@"math/big".Int "esc:0x9", @"math/big".yÂ·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x1a") AndNot (@"math/big".xÂ·3 *@"math/big".Int "esc:0x9", @"math/big".yÂ·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".xÂ·2 *@"math/big".Int "esc:0x9") Append (@"math/big".bufÂ·3 []byte "esc:0x1a", @"math/big".baseÂ·4 int) (? []byte)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x1a") Binomial (@"math/big".nÂ·3 int64, @"math/big".kÂ·4 int64) (? *@"math/big".Int)
	func (@"math/big".xÂ·2 *@"math/big".Int "esc:0x9") Bit (@"math/big".iÂ·3 int) (? uint)
	func (@"math/big".xÂ·2 *@"math/big".Int "esc:0x1") BitLen () (? int)
	func (@"math/big".xÂ·2 *@"math/big".Int "esc:0x22") Bits () (? []@"math/big".Word) { return @"math/big".xÂ·2.@"math/big".abs }
	func (@"math/big".xÂ·2 *@"math/big".Int "esc:0x1") Bytes () (? []byte)
	func (@"math/big".xÂ·2 *@"math/big".Int "esc:0x1") Cmp (@"math/big".yÂ·3 *@"math/big".Int "esc:0x1") (@"math/big".rÂ·1 int)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x1a") Div (@"math/big".xÂ·3 *@"math/big".Int "esc:0x9", @"math/big".yÂ·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".zÂ·3 *@"math/big".Int "esc:0x1a") DivMod (@"math/big".xÂ·4 *@"math/big".Int "esc:0x9", @"math/big".yÂ·5 *@"math/big".Int "esc:0x9", @"math/big".mÂ·6 *@"math/big".Int "esc:0x8a") (? *@"math/big".Int, ? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x1a") Exp (@"math/big".xÂ·3 *@"math/big".Int "esc:0x9", @"math/big".yÂ·4 *@"math/big".Int "esc:0x1", @"math/big".mÂ·5 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".xÂ·1 *@"math/big".Int "esc:0x9") Format (@"math/big".sÂ·2 @"fmt".State, @"math/big".chÂ·3 rune)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x1a") GCD (@"math/big".xÂ·3 *@"math/big".Int "esc:0x9", @"math/big".yÂ·4 *@"math/big".Int "esc:0x9", @"math/big".aÂ·5 *@"math/big".Int "esc:0x9", @"math/big".bÂ·6 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x9") GobDecode (@"math/big".bufÂ·3 []byte "esc:0x1") (? error)
	func (@"math/big".xÂ·3 *@"math/big".Int "esc:0x1") GobEncode () (? []byte, ? error)
	func (@"math/big".xÂ·2 *@"math/big".Int "esc:0x1") Int64 () (? int64) { var @"math/big".vÂ·3 int64; ; @"math/big".vÂ·3 = int64(@"math/big".low64(@"math/big".xÂ·2.@"math/big".abs)); if @"math/big".xÂ·2.@"math/big".neg { @"math/big".vÂ·3 = -@"math/big".vÂ·3 }; return @"math/big".vÂ·3 }
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x1a") Lsh (@"math/big".xÂ·3 *@"math/big".Int "esc:0x9", @"math/big".nÂ·4 uint) (? *@"math/big".Int)
	func (@"math/big".xÂ·3 *@"math/big".Int "esc:0x9") MarshalJSON () (? []byte, ? error)
	func (@"math/big".xÂ·3 *@"math/big".Int "esc:0x9") MarshalText () (@"math/big".textÂ·1 []byte, @"math/big".errÂ·2 error)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x1a") Mod (@"math/big".xÂ·3 *@"math/big".Int "esc:0x9", @"math/big".yÂ·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x1a") ModInverse (@"math/big".gÂ·3 *@"math/big".Int "esc:0x9", @"math/big".nÂ·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x1a") ModSqrt (@"math/big".xÂ·3 *@"math/big".Int "esc:0x9", @"math/big".pÂ·4 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x1a") Mul (@"math/big".xÂ·3 *@"math/big".Int "esc:0x9", @"math/big".yÂ·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x1a") MulRange (@"math/big".aÂ·3 int64, @"math/big".bÂ·4 int64) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x1a") Neg (@"math/big".xÂ·3 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x1a") Not (@"math/big".xÂ·3 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x1a") Or (@"math/big".xÂ·3 *@"math/big".Int "esc:0x9", @"math/big".yÂ·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".xÂ·2 *@"math/big".Int "esc:0x9") ProbablyPrime (@"math/big".nÂ·3 int) (? bool)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x1a") Quo (@"math/big".xÂ·3 *@"math/big".Int "esc:0x9", @"math/big".yÂ·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".zÂ·3 *@"math/big".Int "esc:0x1a") QuoRem (@"math/big".xÂ·4 *@"math/big".Int "esc:0x9", @"math/big".yÂ·5 *@"math/big".Int "esc:0x9", @"math/big".rÂ·6 *@"math/big".Int "esc:0x8a") (? *@"math/big".Int, ? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x1a") Rand (@"math/big".rndÂ·3 *@"math/rand".Rand "esc:0x9", @"math/big".nÂ·4 *@"math/big".Int "esc:0x1") (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x1a") Rem (@"math/big".xÂ·3 *@"math/big".Int "esc:0x9", @"math/big".yÂ·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x1a") Rsh (@"math/big".xÂ·3 *@"math/big".Int "esc:0x9", @"math/big".nÂ·4 uint) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x9") Scan (@"math/big".sÂ·3 @"fmt".ScanState, @"math/big".chÂ·4 rune) (? error)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x1a") Set (@"math/big".xÂ·3 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x1a") SetBit (@"math/big".xÂ·3 *@"math/big".Int "esc:0x9", @"math/big".iÂ·4 int, @"math/big".bÂ·5 uint) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x12") SetBits (@"math/big".absÂ·3 []@"math/big".Word) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x1a") SetBytes (@"math/big".bufÂ·3 []byte "esc:0x1") (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x1a") SetInt64 (@"math/big".xÂ·3 int64) (? *@"math/big".Int)
	func (@"math/big".zÂ·3 *@"math/big".Int "esc:0x1a") SetString (@"math/big".sÂ·4 string, @"math/big".baseÂ·5 int) (? *@"math/big".Int, ? bool)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x1a") SetUint64 (@"math/big".xÂ·3 uint64) (? *@"math/big".Int)
	func (@"math/big".xÂ·2 *@"math/big".Int "esc:0x1") Sign () (? int) { if len(@"math/big".xÂ·2.@"math/big".abs) == int(0x0) { return int(0x0) }; if @"math/big".xÂ·2.@"math/big".neg { return int(-0x1) }; return int(0x1) }
	func (@"math/big".xÂ·2 *@"math/big".Int "esc:0x9") String () (? string)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x1a") Sub (@"math/big".xÂ·3 *@"math/big".Int "esc:0x9", @"math/big".yÂ·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".xÂ·2 *@"math/big".Int "esc:0x9") Text (@"math/big".baseÂ·3 int) (? string)
	func (@"math/big".xÂ·2 *@"math/big".Int "esc:0x1") Uint64 () (? uint64) { return @"math/big".low64(@"math/big".xÂ·2.@"math/big".abs) }
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x9") UnmarshalJSON (@"math/big".textÂ·3 []byte) (? error)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x9") UnmarshalText (@"math/big".textÂ·3 []byte) (? error)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x1a") Xor (@"math/big".xÂ·3 *@"math/big".Int "esc:0x9", @"math/big".yÂ·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x1a") @"math/big".binaryGCD (@"math/big".aÂ·3 *@"math/big".Int "esc:0x9", @"math/big".bÂ·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x1a") @"math/big".modSqrt3Mod4Prime (@"math/big".xÂ·3 *@"math/big".Int "esc:0x9", @"math/big".pÂ·4 *@"math/big".Int "esc:0x9") (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x1a") @"math/big".modSqrtTonelliShanks (@"math/big".xÂ·3 *@"math/big".Int "esc:0x9", @"math/big".pÂ·4 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".zÂ·4 *@"math/big".Int "esc:0x1a") @"math/big".scan (@"math/big".rÂ·5 @"io".ByteScanner, @"math/big".baseÂ·6 int) (? *@"math/big".Int, ? int, ? error)
	type @"crypto/elliptic".CurveParams struct { P *@"math/big".Int; N *@"math/big".Int; B *@"math/big".Int; Gx *@"math/big".Int; Gy *@"math/big".Int; BitSize int; Name string }
	func (@"crypto/elliptic".curveÂ·3 *@"crypto/elliptic".CurveParams "esc:0x9") Add (@"crypto/elliptic".x1Â·4 *@"math/big".Int "esc:0x9", @"crypto/elliptic".y1Â·5 *@"math/big".Int "esc:0x9", @"crypto/elliptic".x2Â·6 *@"math/big".Int "esc:0x9", @"crypto/elliptic".y2Â·7 *@"math/big".Int "esc:0x9") (? *@"math/big".Int, ? *@"math/big".Int)
	func (@"crypto/elliptic".curveÂ·3 *@"crypto/elliptic".CurveParams "esc:0x9") Double (@"crypto/elliptic".x1Â·4 *@"math/big".Int "esc:0x9", @"crypto/elliptic".y1Â·5 *@"math/big".Int "esc:0x9") (? *@"math/big".Int, ? *@"math/big".Int)
	func (@"crypto/elliptic".curveÂ·2 *@"crypto/elliptic".CurveParams "esc:0x9") IsOnCurve (@"crypto/elliptic".xÂ·3 *@"math/big".Int "esc:0x9", @"crypto/elliptic".yÂ·4 *@"math/big".Int "esc:0x9") (? bool)
	func (@"crypto/elliptic".curveÂ·2 *@"crypto/elliptic".CurveParams "esc:0x12") Params () (? *@"crypto/elliptic".CurveParams) { return @"crypto/elliptic".curveÂ·2 }
	func (@"crypto/elliptic".curveÂ·3 *@"crypto/elliptic".CurveParams "esc:0x9") ScalarBaseMult (@"crypto/elliptic".kÂ·4 []byte "esc:0x1") (? *@"math/big".Int, ? *@"math/big".Int)
	func (@"crypto/elliptic".curveÂ·3 *@"crypto/elliptic".CurveParams "esc:0x9") ScalarMult (@"crypto/elliptic".BxÂ·4 *@"math/big".Int "esc:0x9", @"crypto/elliptic".ByÂ·5 *@"math/big".Int "esc:0x9", @"crypto/elliptic".kÂ·6 []byte "esc:0x1") (? *@"math/big".Int, ? *@"math/big".Int)
	func (@"crypto/elliptic".curveÂ·4 *@"crypto/elliptic".CurveParams "esc:0x9") @"crypto/elliptic".addJacobian (@"crypto/elliptic".x1Â·5 *@"math/big".Int "esc:0x9", @"crypto/elliptic".y1Â·6 *@"math/big".Int "esc:0x9", @"crypto/elliptic".z1Â·7 *@"math/big".Int "esc:0x9", @"crypto/elliptic".x2Â·8 *@"math/big".Int "esc:0x9", @"crypto/elliptic".y2Â·9 *@"math/big".Int "esc:0x9", @"crypto/elliptic".z2Â·10 *@"math/big".Int "esc:0x9") (? *@"math/big".Int, ? *@"math/big".Int, ? *@"math/big".Int)
	func (@"crypto/elliptic".curveÂ·3 *@"crypto/elliptic".CurveParams "esc:0x9") @"crypto/elliptic".affineFromJacobian (@"crypto/elliptic".xÂ·4 *@"math/big".Int "esc:0x9", @"crypto/elliptic".yÂ·5 *@"math/big".Int "esc:0x9", @"crypto/elliptic".zÂ·6 *@"math/big".Int "esc:0x9") (@"crypto/elliptic".xOutÂ·1 *@"math/big".Int, @"crypto/elliptic".yOutÂ·2 *@"math/big".Int)
	func (@"crypto/elliptic".curveÂ·4 *@"crypto/elliptic".CurveParams "esc:0x9") @"crypto/elliptic".doubleJacobian (@"crypto/elliptic".xÂ·5 *@"math/big".Int "esc:0x9", @"crypto/elliptic".yÂ·6 *@"math/big".Int "esc:0x9", @"crypto/elliptic".zÂ·7 *@"math/big".Int "esc:0x9") (? *@"math/big".Int, ? *@"math/big".Int, ? *@"math/big".Int)
	type @"crypto/elliptic".Curve interface { Add(@"crypto/elliptic".x1 *@"math/big".Int, @"crypto/elliptic".y1 *@"math/big".Int, @"crypto/elliptic".x2 *@"math/big".Int, @"crypto/elliptic".y2 *@"math/big".Int) (@"crypto/elliptic".x *@"math/big".Int, @"crypto/elliptic".y *@"math/big".Int); Double(@"crypto/elliptic".x1 *@"math/big".Int, @"crypto/elliptic".y1 *@"math/big".Int) (@"crypto/elliptic".x *@"math/big".Int, @"crypto/elliptic".y *@"math/big".Int); IsOnCurve(@"crypto/elliptic".x *@"math/big".Int, @"crypto/elliptic".y *@"math/big".Int) (? bool); Params() (? *@"crypto/elliptic".CurveParams); ScalarBaseMult(@"crypto/elliptic".k []byte) (@"crypto/elliptic".x *@"math/big".Int, @"crypto/elliptic".y *@"math/big".Int); ScalarMult(@"crypto/elliptic".x1 *@"math/big".Int, @"crypto/elliptic".y1 *@"math/big".Int, @"crypto/elliptic".k []byte) (@"crypto/elliptic".x *@"math/big".Int, @"crypto/elliptic".y *@"math/big".Int) }
	type @"".PublicKey struct { ? @"crypto/elliptic".Curve; X *@"math/big".Int; Y *@"math/big".Int }
	type @"crypto".PublicKey interface {}
	type @"io".Reader interface { Read(@"io".p []byte) (@"io".n int, @"io".err error) }
	import hash "hash" // indirect
	type @"hash".Hash interface { BlockSize() (? int); Reset(); Size() (? int); Sum(@"hash".b []byte) (? []byte); Write(@"io".p []byte) (@"io".n int, @"io".err error) }
	type @"crypto".Hash uint
	func (@"crypto".hÂ·2 @"crypto".Hash) Available () (? bool) { return @"crypto".hÂ·2 < @"crypto".Hash(0x10) && @"crypto".hashes[@"crypto".hÂ·2] != nil }
	func (@"crypto".hÂ·2 @"crypto".Hash) HashFunc () (? @"crypto".Hash) { return @"crypto".hÂ·2 }
	func (@"crypto".hÂ·2 @"crypto".Hash) New () (? @"hash".Hash)
	func (@"crypto".hÂ·2 @"crypto".Hash) Size () (? int)
	type @"crypto".SignerOpts interface { HashFunc() (? @"crypto".Hash) }
	type @"".PrivateKey struct { ? @"".PublicKey; D *@"math/big".Int }
	func (@"".privÂ·2 *@"".PrivateKey "esc:0x12") Public () (? @"crypto".PublicKey) { return &@"".privÂ·2.PublicKey }
	func (@"".privÂ·3 *@"".PrivateKey "esc:0x9") Sign (@"".randÂ·4 @"io".Reader, @"".msgÂ·5 []byte, @"".optsÂ·6 @"crypto".SignerOpts "esc:0x1") (? []byte, ? error)
	func @"".GenerateKey (@"".cÂ·3 @"crypto/elliptic".Curve, @"".randÂ·4 @"io".Reader) (@"".privÂ·1 *@"".PrivateKey, @"".errÂ·2 error)
	func @"".Sign (@"".randÂ·4 @"io".Reader, @"".privÂ·5 *@"".PrivateKey "esc:0x9", @"".hashÂ·6 []byte) (@"".rÂ·1 *@"math/big".Int, @"".sÂ·2 *@"math/big".Int, @"".errÂ·3 error)
	func @"".Verify (@"".pubÂ·2 *@"".PublicKey "esc:0x9", @"".hashÂ·3 []byte "esc:0x1", @"".rÂ·4 *@"math/big".Int "esc:0x9", @"".sÂ·5 *@"math/big".Int) (? bool)
	func @"".init ()
	func @"math/big".low64 (@"math/big".zÂ·2 @"math/big".nat "esc:0x1") (? uint64) { if len(@"math/big".zÂ·2) == int(0x0) { return uint64(0x0) }; var @"math/big".vÂ·3 uint64; ; @"math/big".vÂ·3 = uint64(@"math/big".zÂ·2[int(0x0)]); if true && len(@"math/big".zÂ·2) > int(0x1) { @"math/big".vÂ·3 |= uint64(@"math/big".zÂ·2[int(0x1)]) << uint(0x20) }; return @"math/big".vÂ·3 }
	var @"crypto".hashes []func() (? @"hash".Hash)

$$
_go_.o          0           0     0     644     103409    `
go object darwin 386 go1.6 X:none

!
  go13ldcrypto.acrypto/aes.acrypto/cipher.a"crypto/elliptic.acrypto/sha512.aencoding/asn1.aio.amath/big.a ş."".(*PrivateKey).Public  `  `e‹    ;av1Û‹\$ƒû t‰\$ÇD$    Ã‰ëïè    ëÑÌ      >  $type.*"".PublicKey   R  0runtime.morestack_noctxt      "".~r0 *type.crypto.PublicKey "".priv  &type.*"".PrivateKey 0 0 ~  TgclocalsÂ·0b86ef39f3fed835f14ba5f4d7c62fa2 TgclocalsÂ·33cdeccccebe80329f1fdbee7f5874cb   B$GOROOT/src/crypto/ecdsa/ecdsa.goş*"".(*PrivateKey).Sign      e‹    ;a†ö   ƒì81Û‰\$\‰\$`‰\$d1Û‰\$h‰\$l‹\$@‰$‹\$D‰\$‹\$<‰\$‹\$H‰\$‹\$L‰\$‹\$P‰\$è    ‹T$‹L$‹D$ ‹l$$‰l$,‰D$(ƒø t1Û‰\$\‰\$`‰\$d‰D$h‰l$lƒÄ8Ã1Û‰\$0‰\$4‰T$0‰L$4Ç$    \$0‰\$ÇD$    è    \$ü‹‰$‹K‰L$è    ‹t$‹l$‹T$‹L$‹D$‰t$\‰l$`‰T$d‰L$h‰D$lƒÄ8Ãè    éğşÿÿ      ¶  "".Sign   Ö  ,type."".ecdsaSignature   €  runtime.convT2E   ¬  *encoding/asn1.Marshal     0runtime.morestack_noctxt   hp  "".autotmp_0004 ,type."".ecdsaSignature "".err type.error "".~r4 Xtype.error "".~r3 @type.[]uint8 "".opts 0,type.crypto.SignerOpts "".msg type.[]uint8 "".rand type.io.Reader "".priv  &type.*"".PrivateKey p‚opoo  +H	p
  ZeQ TgclocalsÂ·2c3c751f5a9f71ad83dad407bc98598a TgclocalsÂ·2c78d3ad9d760b5f66e2e47be684c787   B$GOROOT/src/crypto/ecdsa/ecdsa.goş&"".randFieldElement  à  àe‹    ;a†V  ƒì@1Û1Û‰\$X‰\$\ÇD$T    ‹\$H‰$‹\$D‹[ ÿÓ‹D$‰D$ ‹h‰éÁùÁééÁùƒÁÇ$    ‰È™‰D$‰T$‰È™‰D$‰T$è    ‹T$‹L$‹D$‹\$L‰$‹\$P‰\$‰T$$‰T$‰L$(‰L$‰D$,‰D$è    ‹D$‹\$‰\$\‰D$Xƒø tƒÄ@ÃÇ$    è    ‹\$‰$‹\$$‰\$‹\$(‰\$‹\$,‰\$è    ‹\$‰\$T1Ûˆ\$0‰\$4‰\$8‰\$<\$0‰$‹\$ ‹k‰l$‹    ‰\$è    ‹L$T‹D$‰$‰L$‰D$è    ‹D$T‰$‰D$‹    ‰\$è    ƒÄ@Ãè    éşÿÿ      j       ª  type.[]uint8   à  "runtime.makeslice   Ğ  io.ReadFull     "type.math/big.Int   š  "runtime.newobject   â  0math/big.(*Int).SetBytes   Æ  "".one   Ø  &math/big.(*Int).Sub   ˆ  &math/big.(*Int).Mod   ª  "".one   ¼  &math/big.(*Int).Add   Î  0runtime.morestack_noctxt   8€  "".autotmp_0013 "type.math/big.Int "".autotmp_0011  type.int "".autotmp_0010  $type.*math/big.Int "".b 7type.[]uint8 "".params ?Btype.*crypto/elliptic.CurveParams "".err (type.error "".k  $type.*math/big.Int "".rand type.io.Reader "".c  4type.crypto/elliptic.Curve €±€  ğ 4¨'E8	8;
  5:8%$;E TgclocalsÂ·c5be8ba0fa1d10f0bd8ec3798363f251 TgclocalsÂ·6eb3d79136cbc4fbd79b029239cb7789   B$GOROOT/src/crypto/ecdsa/ecdsa.goş"".GenerateKey  À  Àe‹    ;a†‚  ƒì01Û1Û‰\$H‰\$LÇD$D    ‹\$4‰$‹\$8‰\$‹\$<‰\$‹\$@‰\$è    ‹\$‰\$‹D$‹\$‰\$L‰D$Hƒø tƒÄ0ÃÇ$    è    ‹L$‰L$D‹l$4‰)‹l$8€=     …ã   ‰i‹D$ƒù „Ì   €=     …«   ‰A‹\$‰$è    ‹T$‹L$‹D$‰T$$‰T$‰L$(‰L$‰D$,‰D$‹\$8‰$‹\$4‹[$ÿÓ‹D$‹\$‰\$ ‹\$Dƒû tO€=     u5‰C‹D$ ‹\$Dƒû t!€=     u‰CƒÄ0Ãs‰4$‰D$è    ëë‰ëÛs‰4$‰D$è    ë½‰ë­q‰4$‰D$è    éDÿÿÿ‰é-ÿÿÿq‰4$‰l$è    ‹L$Déÿÿÿè    édşÿÿÌÌÌÌ        &"".randFieldElement   Ş  $type."".PrivateKey   è  "runtime.newobject   ˜  (runtime.writeBarrier   Ò  (runtime.writeBarrier   ş  *math/big.(*Int).Bytes   ê       œ  (runtime.writeBarrier   Î  (runtime.writeBarrier   €  .runtime.writebarrierptr   ª  .runtime.writebarrierptr   Ô  .runtime.writebarrierptr   Š  .runtime.writebarrierptr   ¦  0runtime.morestack_noctxt   8`  "".autotmp_0023 $type.*math/big.Int "".autotmp_0022  $type.*math/big.Int "".autotmp_0021 type.[]uint8 "".k '$type.*math/big.Int "".err (type.error "".priv  &type.*"".PrivateKey "".rand type.io.Reader "".c  4type.crypto/elliptic.Curve  `X_`È_`]_   LÈ'8	z  F-K–7 TgclocalsÂ·c3e8ad084447b3db377723b14ca5e3b3 TgclocalsÂ·cc403846fece7fb9a38907287267745a   B$GOROOT/src/crypto/ecdsa/ecdsa.goş"".hashToInt  À  Àe‹    ;a†½   ƒì‹\$0‰$‹\$,‹[ ÿÓ‹\$‹k‰,$è    ‹D$‰D$ƒÀ‰ÃÁûÁëÃÁû‰Ø‹\$$9Ã~w‹\$(9Øwh‰D$$Ç$    è    ‹\$‰$‹\$ ‰\$‹\$$‰\$‹\$(‰\$è    ‹L$‹D$$Áà+D$ƒø ~‰$‰L$‰L$‰D$è    ‹L$‰L$4ƒÄÃè    ë“è    é)ÿÿÿÌÌÌÌÌÌÌÌÌ      B       \  ,math/big.(*Int).BitLen   Æ  "type.math/big.Int   Ğ  "runtime.newobject   ˜  0math/big.(*Int).SetBytes   è  &math/big.(*Int).Rsh   Š  $runtime.panicslice   œ  0runtime.morestack_noctxt   08  "".autotmp_0030  type.int "".autotmp_0028  type.int "".ret $type.*math/big.Int "".orderBits type.int "".~r2 ($type.*math/big.Int "".c 4type.crypto/elliptic.Curve "".hash  type.[]uint8 8°78	7 à 8î#4  !’ TgclocalsÂ·ac69ed8bba674801fdf4bb781f82cfa6 TgclocalsÂ·0c8aa8e80191a30eac23f1a218103f16   B$GOROOT/src/crypto/ecdsa/ecdsa.goş "".fermatInverse  à  àe‹    ;a†‰   ƒì(Ç$   ÇD$    è    ‹L$1Ûˆ\$‰\$‰\$ ‰\$$\$‰$‹\$0‰\$‰L$è    ‹\$‰\$Ç$    è    ‹\$‰$‹\$,‰\$‹\$‰\$‹\$0‰\$è    ‹\$‰\$4ƒÄ(Ãè    é]ÿÿÿÌÌÌÌÌÌÌÌÌÌÌÌÌ      F  math/big.NewInt   ¢  &math/big.(*Int).Sub   À  "type.math/big.Int   Ê  "runtime.newobject   ’  &math/big.(*Int).Exp   ´  0runtime.morestack_noctxt   P  "".autotmp_0043 "type.math/big.Int "".autotmp_0042  $type.*math/big.Int "".autotmp_0041  $type.*math/big.Int "".nMinus2 '$type.*math/big.Int "".~r2 $type.*math/big.Int "".N $type.*math/big.Int "".k  $type.*math/big.Int P…O ° ”2<  ".$( TgclocalsÂ·9c91d8a91ac42440a3d1507bc8d2e808 TgclocalsÂ·0a505ec66736deb2f34fa0d910d79932   B$GOROOT/src/crypto/ecdsa/ecdsa.goş"".Sign  À  Àe‹    D$¬;A†¾  ìÔ   1Û1Û‰œ$ø   ‰œ$ü   Ç„$ô       Ç„$ğ       ‹œ$à   ƒû „y  ‹‹k‰l$|‰,$‰L$x‹Y ÿÓ‹\$‹KƒÁ‰ÈÁùÁéÁÁùƒù ~¹    Ç$    ‰È™‰D$‰T$‰È™‰D$‰T$è    ‹T$‹L$‹D$‹œ$Ø   ‰$‹œ$Ü   ‰\$‰”$œ   ‰T$‰Œ$    ‰L$‰„$¤   ‰D$è    ‹D$‹\$‰œ$ü   ‰„$ø   ƒø tÄÔ   Ãè    ‹$‰\$P‹\$‰\$T‹œ$à   ‹k‰,$è    ‹T$‹L$‹D$‰”$¨   ‰T$‰Œ$¬   ‰L$‰„$°   ‰D$‹\$T‰$‹\$P‹[$ÿÓ‹œ$œ   ‰\$‹œ$    ‰\$‹œ$¤   ‰\$‹\$T‰$‹\$P‹[$ÿÓ‹œ$ä   ‰\$‹œ$è   ‰\$‹œ$ì   ‰\$‹\$T‰$‹\$P‹[$ÿÓ1Û‰\$‰\$‰\$‹\$T‰$‹\$P‹[ ÿÓ‹L$‹\$‹D$ƒø ‚¹  ½    ‰Œ$   ‰$‰¬$”   ‰l$‰„$˜   ‰D$è    ‹\$‰\$h‹\$‰\$l‹D$‹\$‰œ$ü   ‰„$ø   ƒø tÇ„$ğ       Ç„$ô       ÄÔ   Ã\$ ‰$»    ‰\$ÇD$   è    ‹T$‹L$‹D$‹\$h‰$‹\$l‰\$‰”$¨   ‰T$‰Œ$¬   ‰L$‰„$°   ‰D$è    ‹\$‰œ$ˆ   ‹\$‰œ$Œ   1Û‰œ$´   ‰œ$¸   ‰œ$¼   ‰œ$À   ‹    1í9è„€  ‹    ‰D$p‰„$¼   ‰L$t‰Œ$À   ‹œ$ˆ   ‰œ$´   ‹œ$Œ   ‰œ$¸   ‹œ$à   ƒû „1  ‹‹k‰l$d‰,$‰L$`‹Y ÿÓ‹\$‹k‰l$L‹œ$´   ‰œ$Ä   ‹œ$¸   ‰œ$È   ‹œ$¼   ‰œ$Ì   ‹œ$À   ‰œ$Ğ   Ç$    ÇD$    ÇD$    œ$Ä   ‰\$ÇD$    è    \$|$ü‹‰‹K‰O‹\$`‰$‹\$d‰\$è    ‹\$‰\$D‹D$‹\$‰œ$ü   ‰„$ø   ƒø tÇ„$ğ       ÄÔ   Ã1Û‰œ$€   ‰œ$„   Ç$    ‹œ$à   |$ü‹‰‹K‰Oœ$€   ‰\$è    ‹l$D¶\$‹”$€   ‰T$X‹Œ$„   ‰L$\€û „Ì  ‰l$‰$‹ZÿÓ‹\$‰\$@‹\$D‰$è    ‹T$‹L$‹D$‹œ$à   ƒû „‰  ‹;‹k‰”$¨   ‰T$‰Œ$¬   ‰L$‰„$°   ‰D$‰l$|‰,$‰|$x‹_$ÿÓ‹D$‰$‰„$ğ   ‰D$‹\$L‰\$è    ‹„$ğ   ‹hƒı …  1Àƒø „)şÿÿ‹œ$ä   ‰$‹œ$è   ‰\$‹œ$ì   ‰\$‹\$`‰\$‹\$d‰\$è    ‹\$‰\$HÇ$    è    ‹\$‰$‹œ$à   ‹k‰l$‹œ$ğ   ‰\$è    ‹D$‰$‰„$ô   ‰D$‹\$H‰\$è    ‹„$ô   ‰$‰D$‹\$@‰\$è    ‹„$ô   ‰$‰D$‹\$L‰\$è    ‹„$ô   ‹hƒı u1Àƒø „LıÿÿÄÔ   Ã¶€û t¸ÿÿÿÿëá¸   ëÚ¶€û t
¸ÿÿÿÿéëşÿÿ¸   éáşÿÿ‰épşÿÿ‰,$‹\$L‰\$è    ‹\$‰\$@é+şÿÿ‰éÈüÿÿÇ$    ÇD$    ÇD$    è    ‹D$é[üÿÿè    ‰é€ùÿÿè    é$ùÿÿÌÌÌÌV      Ê       –  type.[]uint8   Ì  "runtime.makeslice   Ú  io.ReadFull   ¨  "crypto/sha512.New   ê  *math/big.(*Int).Bytes   è       Ê       ¬       è       â  (crypto/aes.NewCipher   Š
  8go.string."IV for ECDSA CTR"   ¬
  2runtime.stringtoslicebyte   ®  (crypto/cipher.NewCTR   ¢  0go.itab.*"".zr.io.Reader   Â  "".zeroReader   ô       „  >type.crypto/cipher.StreamReader   ”  type.io.Reader   ¤  Xgo.itab.crypto/cipher.StreamReader.io.Reader   Ô  runtime.convT2I   ¢  &"".randFieldElement   º  $type."".invertible   †  $runtime.assertI2I2   ò       –  *math/big.(*Int).Bytes   ¾       ø  &math/big.(*Int).Mod     "".hashToInt   ¼  "type.math/big.Int   Æ  "runtime.newobject     &math/big.(*Int).Mul   Î  &math/big.(*Int).Add   „  &math/big.(*Int).Mul   º  &math/big.(*Int).Mod      "".fermatInverse   Ä  type.*"".zr   Ô  type.io.Reader   ä  0go.itab.*"".zr.io.Reader   î   runtime.typ2Itab   Š  $runtime.panicslice   ¦  0runtime.morestack_noctxt   P¨  <"".autotmp_0058  type.*uint8 "".autotmp_0057 çtype.[32]uint8 "".autotmp_0056  type.int "".autotmp_0055  type.int "".autotmp_0053  type.int "".autotmp_0052  type.[]uint8 "".autotmp_0051 §$type."".invertible "".autotmp_0050 >type.crypto/cipher.StreamReader "".autotmp_0049  Btype.*crypto/elliptic.CurveParams "".autotmp_0048 —2type.crypto/cipher.Stream "".autotmp_0047  type.[]uint8 "".autotmp_0046  type.[]uint8 "".autotmp_0045 Wtype.[]uint8 "".e —$type.*math/big.Int 
"".in ÷$type."".invertible "".kInv §$type.*math/big.Int "".k Ÿ$type.*math/big.Int "".N $type.*math/big.Int "".c ç4type.crypto/elliptic.Curve "".csprng ?>type.crypto/cipher.StreamReader "".block ×0type.crypto/cipher.Block "".key ‡type.[]uint8 
"".md ‡type.hash.Hash "".entropy otype.[]uint8 "".err @type.error "".s 8$type.*math/big.Int "".r 0$type.*math/big.Int "".hash type.[]uint8 "".priv &type.*"".PrivateKey "".rand  type.io.Reader L¨ø§¨é§¨Ì§¨÷§¨§ à Â¨B<.JO118DtH

¥e
b
=5"
	#	% d e‡'!qO¡A¤o™7qSD…	0 TgclocalsÂ·4ec6022d7a8ad5c13bf62802871a1f5c TgclocalsÂ·a1df2b8bd226f90ce1ff0c3be7aef311   B$GOROOT/src/crypto/ecdsa/ecdsa.goş"".Verify  €  €e‹    D$ä;A†  ìœ   1À‰„$Œ   ‰„$   ‰„$”   ‰„$˜   ‹œ$    ƒû „İ  ‹‹k‰l$`‰,$‰L$\‹Y ÿÓ‹”$°   ‹\$‹s‹jƒı …’  1Àƒø „\  ‹„$´   ‹hƒı …X  1Àƒø „>  ‰$‰t$H‰t$è    ‹\$ƒû   ‹œ$´   ‰$‹\$H‰\$è    ‹\$ƒû î  ‹œ$¤   ‰$‹œ$¨   ‰\$‹œ$¬   ‰\$‹\$\‰\$‹\$`‰\$è    ‹\$‰\$D1Û‰\$l‰\$pÇ$    ‹\$\‰\$‹\$`‰\$\$l‰\$è    ‹¬$´   ¶\$‹T$l‰T$T‹L$p‰L$X€û „  ‰l$‰$‹ZÿÓ‹D$‹\$D‰$‹\$D‰\$‰D$8‰D$è    ‹D$‰$‰D$@‰D$‹\$H‰\$è    ‹D$8‰$‹œ$°   ‰\$‰D$è    ‹D$‰$‰D$<‰D$‹\$H‰\$è    1Û‰\$d‰\$hÇ$    ‹\$\‰\$‹\$`‰\$\$d‰\$è    ‹L$@¶\$‰Ø‹\$d‰\$L‹\$h‰\$P€ø „[  ‰$è    ‹\$‰œ$€   ‹\$‰œ$„   ‹\$‰œ$ˆ   ‹\$<‰$è    ‹´$    ‹T$‹L$‹D$‹n‰l$‹n‰l$‹œ$€   ‰\$‹œ$„   ‰\$‹œ$ˆ   ‰\$‰T$t‰T$‰L$x‰L$‰D$|‰D$ ‹\$P‰$‹\$L‹[ÿÓ‹L$$‹T$(‹iƒı …Œ   1Àƒø u‹jƒı ug1Àƒø uÆ„$¸    Äœ   Ã‰$‰L$4‰L$‹\$H‰\$è    ‹\$4‰$‹œ$°   ‰\$è    ‹\$ƒû tÆ„$¸    Äœ   ÃÆ„$¸   ëï¶€û t¸ÿÿÿÿëŒ¸   ë…¶€û t
¸ÿÿÿÿédÿÿÿ¸   éZÿÿÿ‰$è    ‹T$‹L$‹D$‰”$€   ‰T$‰Œ$„   ‰L$‰„$ˆ   ‰D$‹\$`‰$‹\$\‹[$ÿÓ‹\$‰\$0‹\$‰\$,‹\$<‰$è    ‹´$    ‹T$‹L$‹D$‹n‰l$‹n‰l$‰”$€   ‰T$‰Œ$„   ‰L$‰„$ˆ   ‰D$‹\$`‰$‹\$\‹[(ÿÓ‹L$‹D$‹\$0‰\$‹\$,‰\$‰L$‰D$‹\$`‰$‹\$\‹[ÿÓ‹L$‹T$é\şÿÿ1Ûˆœ$Œ   ‰œ$   ‰œ$”   ‰œ$˜   œ$Œ   ‰$‰l$‹\$H‰\$è    ‹D$é²üÿÿÆ„$¸    Äœ   ÃÆ„$¸    Äœ   Ã¶€û t
¸ÿÿÿÿé˜ûÿÿ¸   éûÿÿ¶€û t
¸ÿÿÿÿé^ûÿÿ¸   éTûÿÿ‰éûÿÿè    éÊúÿÿÌÌÌÌÌÌÌÌÌÌ4      ¶       Ø  &math/big.(*Int).Cmp      &math/big.(*Int).Cmp   ¤  "".hashToInt   Ö  $type."".invertible     $runtime.assertI2I2   ö       ²  &math/big.(*Int).Mul   ê  &math/big.(*Int).Mod      &math/big.(*Int).Mul   Ø  &math/big.(*Int).Mod   ú  (type."".combinedMult   ´  $runtime.assertI2I2   Œ	  *math/big.(*Int).Bytes   æ	  *math/big.(*Int).Bytes   ¾       Ü  &math/big.(*Int).Mod   Š  &math/big.(*Int).Cmp   Â  *math/big.(*Int).Bytes   À       ô  *math/big.(*Int).Bytes   œ       ü       „  4math/big.(*Int).ModInverse   Ú  0runtime.morestack_noctxt   8¸  8"".autotmp_0093 "type.math/big.Int "".autotmp_0092  type.int "".autotmp_0091  type.int "".autotmp_0090  type.int "".autotmp_0089  type.[]uint8 "".autotmp_0088  type.[]uint8 "".autotmp_0087 Otype.[]uint8 "".autotmp_0086 7type.[]uint8 "".autotmp_0085 o(type."".combinedMult "".autotmp_0083 _$type."".invertible "".autotmp_0081  type.int "".autotmp_0080  type.int 
"".y1 ß$type.*math/big.Int 
"".x1 ×$type.*math/big.Int "".opt Ÿ(type."".combinedMult "".x Ï$type.*math/big.Int 
"".u2 ¿$type.*math/big.Int 
"".u1 ·$type.*math/big.Int 
"".in $type."".invertible "".w Ç$type.*math/big.Int "".e ¯$type.*math/big.Int "".N §$type.*math/big.Int "".c 4type.crypto/elliptic.Curve "".~r4 0type.bool "".s ($type.*math/big.Int "".r  $type.*math/big.Int "".hash type.[]uint8 "".pub  $type.*"".PublicKey F¸ÿ·¸F·¸ü·¸·¸?· À
 ~¼85A=S
 R§"92	Uf0#=8 R [Pœ4.,-mN\Y…C TgclocalsÂ·37e27975c5fdaa0f8e0e6013a5b8e19b TgclocalsÂ·f29d36ab78ed428bc5e044f7c7b1d471   B$GOROOT/src/crypto/ecdsa/ecdsa.goş"".(*zr).Read  À  Àe‹    ;avAƒì‹T$1Û1Û‰\$ ‰\$$ƒú t‹L$‰$‰T$è    ‹T$‰ÓK‰T$1Û‰\$ ‰\$$ƒÄÃè    ë¬ÌÌÌÌÌÌÌÌÌÌÌÌ      `  runtime.memclr   œ  0runtime.morestack_noctxt   8  "".autotmp_0101  type.int "".autotmp_0098  type.int "".err (type.error "".n  type.int "".dst type.[]uint8 "".z  type.*"".zr = ` š 
 /1 TgclocalsÂ·b60dc0a6046c556b02baa766a3fd5a27 TgclocalsÂ·33cdeccccebe80329f1fdbee7f5874cb   B$GOROOT/src/crypto/ecdsa/ecdsa.goş"".init      e‹    ;a†®   ƒì¶    €û t¶    €ûuƒÄÃè    Æ    è    è    è    è    è    è    è    è    Ç$    è    ‹\$‰$ÇD$   ÇD$    è    ‹\$€=     u‰    Æ    ƒÄÃ½    ‰,$‰\$è    ëâè    é8ÿÿÿÌÌÌÌÌÌÌÌ,      ,  "".initdoneÂ·   D  "".initdoneÂ·   `  "runtime.throwinit   p  "".initdoneÂ·   |  crypto.init   †  crypto/aes.init     $crypto/cipher.init   š  (crypto/elliptic.init   ¤  $crypto/sha512.init   ®  $encoding/asn1.init   ¸  io.init   Â  math/big.init   Ğ  "type.math/big.Int   Ú  "runtime.newobject   ’  0math/big.(*Int).SetInt64   ¦  (runtime.writeBarrier   ¸  "".one   Ä  "".initdoneÂ·   Ø  "".one   ğ  .runtime.writebarrierptr   ş  0runtime.morestack_noctxt          {  Ğ  ¨e‡;ˆ‡ˆ  /¡ TgclocalsÂ·33cdeccccebe80329f1fdbee7f5874cb TgclocalsÂ·33cdeccccebe80329f1fdbee7f5874cb   B$GOROOT/src/crypto/ecdsa/ecdsa.goş.type..hash."".PublicKey €  €e‹    ;avcƒì‹\$‰$ƒ<$ tK‹\$‰\$è    ‹D$‹\$‰$ƒ<$ t%ƒ$‰D$‰D$ÇD$   è    ‹\$‰\$ƒÄÃ‰    ëÓ‰    ë­è    ëŠÌÌÌÌÌÌÌÌÌÌ      J  "runtime.interhash     runtime.memhash   à  0runtime.morestack_noctxt      "".~r2 type.uintptr "".h type.uintptr "".p  $type.*"".PublicKey  O  € € 
 $\ TgclocalsÂ·0b86ef39f3fed835f14ba5f4d7c62fa2 TgclocalsÂ·33cdeccccebe80329f1fdbee7f5874cb   B$GOROOT/src/crypto/ecdsa/ecdsa.goş*type..eq."".PublicKey €  €e‹    ;a†¤   ƒì$‹\$,ƒû „   ‹3‹k‰l$ ‹\$(ƒû tw‹‹{9òue‰T$‰$‰|$‰|$‰t$‰t$‹l$ ‰l$è    ‹t$,‹T$(¶\$€û t/‹J‹n9ét	ÆD$0 ƒÄ$Ã‹J‹n9ét	ÆD$0 ƒÄ$ÃÆD$0ƒÄ$ÃÆD$0 ƒÄ$Ã‰ë…‰élÿÿÿè    éBÿÿÿÌÌ      ¶  runtime.ifaceeq   ê  0runtime.morestack_noctxt   H  
"".autotmp_0108 4type.crypto/elliptic.Curve "".autotmp_0107 4type.crypto/elliptic.Curve "".~r2 type.bool "".q $type.*"".PublicKey "".p  $type.*"".PublicKey .HpGHGHGHGHG À À 
 Zf TgclocalsÂ·3bb21ca8fe1d99a3e492463bd711418a TgclocalsÂ·a8eabfc4a4514ed6b3b0c61e9680e440   B$GOROOT/src/crypto/ecdsa/ecdsa.goş&"".(*PublicKey).Add €  €e‹    ;avjƒì$‹Y…Ût
|$(9;u‰#‹\$(ƒû tI‹‹k‹\$,‰\$‹\$0‰\$‹\$4‰\$‹\$8‰\$‰l$ ‰,$‰L$‹YÿÓ‹L$‹D$‰L$<‰D$@ƒÄ$Ã‰ë³è    ëƒÌÌÌ      ¸       î  0runtime.morestack_noctxt   8H  "crypto/elliptic.y 0$type.*math/big.Int "crypto/elliptic.x ($type.*math/big.Int $crypto/elliptic.y2  $type.*math/big.Int $crypto/elliptic.x2 $type.*math/big.Int $crypto/elliptic.y1 $type.*math/big.Int $crypto/elliptic.x1 $type.*math/big.Int ""..this  $type.*"".PublicKey HbGHG
 € € 
 \$ TgclocalsÂ·3f3273e6cb8b40c41344569cdb3bf5df TgclocalsÂ·23e8278e2b69a3a75fa59b23c49ed6ad   <autogenerated>ş "".PublicKey.Add €  €e‹    ;av`ƒì$‹Y…Ût
|$(9;u‰#‹L$(‹D$,‹\$8‰\$‹\$<‰\$‹\$@‰\$‹\$D‰\$‰D$ ‰$‰L$‹YÿÓ‹L$‹D$‰L$H‰D$LƒÄ$Ãè    ëÌÌÌÌÌÌÌÌÌÌÌÌÌ      ¬       Ú  0runtime.morestack_noctxt   PH  "crypto/elliptic.y H$type.*math/big.Int "crypto/elliptic.x @$type.*math/big.Int $crypto/elliptic.y2 8$type.*math/big.Int $crypto/elliptic.x2 0$type.*math/big.Int $crypto/elliptic.y1 ($type.*math/big.Int $crypto/elliptic.x1  $type.*math/big.Int ""..this  "type."".PublicKey H\G € € 
 V* TgclocalsÂ·71661cbbb3aac01ffff82ab01d45fbb8 TgclocalsÂ·23e8278e2b69a3a75fa59b23c49ed6ad   <autogenerated>ş,"".(*PublicKey).Double à  àe‹    ;avZƒì‹Y…Ût
|$ 9;u‰#‹\$ ƒû t9‹‹k‹\$$‰\$‹\$(‰\$‰l$‰,$‰L$‹YÿÓ‹L$‹D$‰L$,‰D$0ƒÄÃ‰ëÃè    ë“ÌÌÌ      ˜       Î  0runtime.morestack_noctxt   (8  
"crypto/elliptic.y  $type.*math/big.Int "crypto/elliptic.x $type.*math/big.Int $crypto/elliptic.y1 $type.*math/big.Int $crypto/elliptic.x1 $type.*math/big.Int ""..this  $type.*"".PublicKey 8R787
 p p 
 L$ TgclocalsÂ·13bdb4aeeaf63de3cc223d640262ea59 TgclocalsÂ·23e8278e2b69a3a75fa59b23c49ed6ad   <autogenerated>ş&"".PublicKey.Double à  àe‹    ;avPƒì‹Y…Ût
|$ 9;u‰#‹L$ ‹D$$‹\$0‰\$‹\$4‰\$‰D$‰$‰L$‹YÿÓ‹L$‹D$‰L$8‰D$<ƒÄÃè    ëÌÌÌÌÌÌÌÌÌÌÌÌÌ      Œ       º  0runtime.morestack_noctxt   @8  
"crypto/elliptic.y 8$type.*math/big.Int "crypto/elliptic.x 0$type.*math/big.Int $crypto/elliptic.y1 ($type.*math/big.Int $crypto/elliptic.x1  $type.*math/big.Int ""..this  "type."".PublicKey 8L7 p 
p 
 F* TgclocalsÂ·cde59c54593d9a88e8be0b1914f1516e TgclocalsÂ·23e8278e2b69a3a75fa59b23c49ed6ad   <autogenerated>ş2"".(*PublicKey).IsOnCurve à  àe‹    ;avSƒì‹Y…Ût
|$9;u‰#‹\$ƒû t2‹‹k‹\$ ‰\$‹\$$‰\$‰l$‰,$‰L$‹YÿÓ¶\$ˆ\$(ƒÄÃ‰ëÊè    ëšÌÌÌÌÌÌÌÌÌÌ      ˜       À  0runtime.morestack_noctxt    0  "".~r3 type.bool "crypto/elliptic.y $type.*math/big.Int "crypto/elliptic.x $type.*math/big.Int ""..this  $type.*"".PublicKey 0K/0/ p p 
 L$ TgclocalsÂ·e5d5edcf53e2c122038779d75a487a60 TgclocalsÂ·23e8278e2b69a3a75fa59b23c49ed6ad   <autogenerated>ş,"".PublicKey.IsOnCurve À  Àe‹    ;avIƒì‹Y…Ût
|$9;u‰#‹L$‹D$ ‹\$,‰\$‹\$0‰\$‰D$‰$‰L$‹YÿÓ¶\$ˆ\$4ƒÄÃè    ë¤ÌÌÌÌ      Œ       ¬  0runtime.morestack_noctxt   80  "".~r3 0type.bool "crypto/elliptic.y ($type.*math/big.Int "crypto/elliptic.x  $type.*math/big.Int ""..this  "type."".PublicKey 0E/ ` ` 
 F TgclocalsÂ·d01b73eb76ffa8f00887520b327d3aa3 TgclocalsÂ·23e8278e2b69a3a75fa59b23c49ed6ad   <autogenerated>ş,"".(*PublicKey).Params À  Àe‹    ;avBƒì‹Y…Ût
|$9;u‰#‹\$ƒû t!‹‹k‰l$‰,$‰L$‹Y ÿÓ‹\$‰\$ƒÄÃ‰ëÛè    ë«ÌÌÌÌÌÌÌÌÌÌÌ      x         0runtime.morestack_noctxt      "".~r1 Btype.*crypto/elliptic.CurveParams ""..this  $type.*"".PublicKey  :  ` ` 
 <$ TgclocalsÂ·3f5c1f818fa7055d0400cecd34057162 TgclocalsÂ·23e8278e2b69a3a75fa59b23c49ed6ad   <autogenerated>ş&"".PublicKey.Params     e‹    ;av8ƒì‹Y…Ût
|$9;u‰#‹L$‹D$‰D$‰$‰L$‹Y ÿÓ‹\$‰\$$ƒÄÃè    ëµÌÌÌÌÌ      l       Š  0runtime.morestack_noctxt   (   "".~r1  Btype.*crypto/elliptic.CurveParams ""..this  "type."".PublicKey  4 P P 
 6 TgclocalsÂ·d0110d631ecd4af0947009e36d46dc99 TgclocalsÂ·23e8278e2b69a3a75fa59b23c49ed6ad   <autogenerated>ş<"".(*PublicKey).ScalarBaseMult €  €e‹    ;avbƒì ‹Y…Ût
|$$9;u‰#‹\$$ƒû tA‹‹k‹\$(‰\$‹\$,‰\$‹\$0‰\$‰l$‰,$‰L$‹Y$ÿÓ‹L$‹D$‰L$4‰D$8ƒÄ Ã‰ë»è    ë‹ÌÌÌÌÌÌÌÌÌÌÌ      ¨       Ş  0runtime.morestack_noctxt   0@  "crypto/elliptic.y ($type.*math/big.Int "crypto/elliptic.x  $type.*math/big.Int "crypto/elliptic.k type.[]uint8 ""..this  $type.*"".PublicKey @Z?@? € € 
 T, TgclocalsÂ·d98f60bd8519d0c68364b2a1d83af357 TgclocalsÂ·23e8278e2b69a3a75fa59b23c49ed6ad   <autogenerated>ş6"".PublicKey.ScalarBaseMult à  àe‹    ;avXƒì ‹Y…Ût
|$$9;u‰#‹L$$‹D$(‹\$4‰\$‹\$8‰\$‹\$<‰\$‰D$‰$‰L$‹Y$ÿÓ‹L$‹D$‰L$@‰D$DƒÄ Ãè    ë•ÌÌÌÌÌ      œ       Ê  0runtime.morestack_noctxt   H@  "crypto/elliptic.y @$type.*math/big.Int "crypto/elliptic.x 8$type.*math/big.Int "crypto/elliptic.k  type.[]uint8 ""..this  "type."".PublicKey @T? p p 
 N" TgclocalsÂ·01bc52eaf25414f97ebedc96f60fbb43 TgclocalsÂ·23e8278e2b69a3a75fa59b23c49ed6ad   <autogenerated>ş4"".(*PublicKey).ScalarMult     e‹    ;avrƒì(‹Y…Ût
|$,9;u‰#‹\$,ƒû tQ‹‹k‹\$0‰\$‹\$4‰\$‹\$8‰\$‹\$<‰\$‹\$@‰\$‰l$$‰,$‰L$ ‹Y(ÿÓ‹L$‹D$‰L$D‰D$HƒÄ(Ã‰ë«è    éxÿÿÿÌÌÌÌÌÌÌÌ      È       ş  0runtime.morestack_noctxt   @P  "crypto/elliptic.y 8$type.*math/big.Int "crypto/elliptic.x 0$type.*math/big.Int "crypto/elliptic.k type.[]uint8 $crypto/elliptic.y1 $type.*math/big.Int $crypto/elliptic.x1 $type.*math/big.Int ""..this  $type.*"".PublicKey PjOPO   
 d, TgclocalsÂ·ecc591e57c9cfd5780396a91917d5274 TgclocalsÂ·23e8278e2b69a3a75fa59b23c49ed6ad   <autogenerated>ş."".PublicKey.ScalarMult €  €e‹    ;avhƒì(‹Y…Ût
|$,9;u‰#‹L$,‹D$0‹\$<‰\$‹\$@‰\$‹\$D‰\$‹\$H‰\$‹\$L‰\$‰D$$‰$‰L$ ‹Y(ÿÓ‹L$‹D$‰L$P‰D$TƒÄ(Ãè    ë…ÌÌÌÌÌ      ¼       ê  0runtime.morestack_noctxt   XP  "crypto/elliptic.y P$type.*math/big.Int "crypto/elliptic.x H$type.*math/big.Int "crypto/elliptic.k 0type.[]uint8 $crypto/elliptic.y1 ($type.*math/big.Int $crypto/elliptic.x1  $type.*math/big.Int ""..this  "type."".PublicKey PdO € € 
 ^" TgclocalsÂ·9423f8cc2bff62b1506ceac7285779a8 TgclocalsÂ·23e8278e2b69a3a75fa59b23c49ed6ad   <autogenerated>ş0type..hash."".PrivateKey €  €e‹    ;avcƒì‹\$‰$ƒ<$ tK‹\$‰\$è    ‹D$‹\$‰$ƒ<$ t%ƒ$‰D$‰D$ÇD$   è    ‹\$‰\$ƒÄÃ‰    ëÓ‰    ë­è    ëŠÌÌÌÌÌÌÌÌÌÌ      J  .type..hash."".PublicKey     runtime.memhash   à  0runtime.morestack_noctxt      "".~r2 type.uintptr "".h type.uintptr "".p  &type.*"".PrivateKey  O  € € 
 $\ TgclocalsÂ·0b86ef39f3fed835f14ba5f4d7c62fa2 TgclocalsÂ·33cdeccccebe80329f1fdbee7f5874cb   B$GOROOT/src/crypto/ecdsa/ecdsa.goş,type..eq."".PrivateKey À  Àe‹    ;a†¼   ƒì,‹L$0ƒù „¥   ‹D$4ƒø „‘   ‰D$‹0‹h‰l$(‰L$‹‹y9òun‰T$‰$‰|$ ‰|$‰t$$‰t$‹l$(‰l$è    ‹t$‹T$¶\$€û t8‹N‹j9éu.‹N‹j9éu$‹\$0‹K‹\$4‹k9ét	ÆD$8 ƒÄ,ÃÆD$8ƒÄ,ÃÆD$8 ƒÄ,Ã‰ éhÿÿÿ‰éTÿÿÿè    é*ÿÿÿÌÌÌÌÌÌÌÌÌÌ      Î  runtime.ifaceeq   š  0runtime.morestack_noctxt   X  "".autotmp_0150 4type.crypto/elliptic.Curve "".autotmp_0149 4type.crypto/elliptic.Curve "".autotmp_0148 /$type.*"".PublicKey "".autotmp_0147 '$type.*"".PublicKey "".~r2 type.bool "".q &type.*"".PrivateKey "".p  &type.*"".PrivateKey (X˜WXWXWXW à à 
 fz TgclocalsÂ·51af24152615272c3d9efc8538f95767 TgclocalsÂ·34eab47d33fa46b254c22cdccfd2dc77   B$GOROOT/src/crypto/ecdsa/ecdsa.goş("".(*PrivateKey).Add €  €e‹    ;avjƒì$‹Y…Ût
|$(9;u‰#‹\$(ƒû tI‹‹k‹\$,‰\$‹\$0‰\$‹\$4‰\$‹\$8‰\$‰l$ ‰,$‰L$‹YÿÓ‹L$‹D$‰L$<‰D$@ƒÄ$Ã‰ë³è    ëƒÌÌÌ      ¸       î  0runtime.morestack_noctxt   8H  "crypto/elliptic.y 0$type.*math/big.Int "crypto/elliptic.x ($type.*math/big.Int $crypto/elliptic.y2  $type.*math/big.Int $crypto/elliptic.x2 $type.*math/big.Int $crypto/elliptic.y1 $type.*math/big.Int $crypto/elliptic.x1 $type.*math/big.Int ""..this  &type.*"".PrivateKey HbGHG
 € € 
 \$ TgclocalsÂ·3f3273e6cb8b40c41344569cdb3bf5df TgclocalsÂ·23e8278e2b69a3a75fa59b23c49ed6ad   <autogenerated>ş""".PrivateKey.Add €  €e‹    ;av`ƒì$‹Y…Ût
|$(9;u‰#‹L$(‹D$,‹\$<‰\$‹\$@‰\$‹\$D‰\$‹\$H‰\$‰D$ ‰$‰L$‹YÿÓ‹L$‹D$‰L$L‰D$PƒÄ$Ãè    ëÌÌÌÌÌÌÌÌÌÌÌÌÌ      ¬       Ú  0runtime.morestack_noctxt   XH  "crypto/elliptic.y P$type.*math/big.Int "crypto/elliptic.x H$type.*math/big.Int $crypto/elliptic.y2 @$type.*math/big.Int $crypto/elliptic.x2 8$type.*math/big.Int $crypto/elliptic.y1 0$type.*math/big.Int $crypto/elliptic.x1 ($type.*math/big.Int ""..this  $type."".PrivateKey H\G € € 
 V* TgclocalsÂ·195b7f0f52fd688f87cdc11f42cf3639 TgclocalsÂ·23e8278e2b69a3a75fa59b23c49ed6ad   <autogenerated>ş."".(*PrivateKey).Double à  àe‹    ;avZƒì‹Y…Ût
|$ 9;u‰#‹\$ ƒû t9‹‹k‹\$$‰\$‹\$(‰\$‰l$‰,$‰L$‹YÿÓ‹L$‹D$‰L$,‰D$0ƒÄÃ‰ëÃè    ë“ÌÌÌ      ˜       Î  0runtime.morestack_noctxt   (8  
"crypto/elliptic.y  $type.*math/big.Int "crypto/elliptic.x $type.*math/big.Int $crypto/elliptic.y1 $type.*math/big.Int $crypto/elliptic.x1 $type.*math/big.Int ""..this  &type.*"".PrivateKey 8R787
 p  p 
 L$ TgclocalsÂ·13bdb4aeeaf63de3cc223d640262ea59 TgclocalsÂ·23e8278e2b69a3a75fa59b23c49ed6ad   <autogenerated>ş("".PrivateKey.Double à  àe‹    ;avPƒì‹Y…Ût
|$ 9;u‰#‹L$ ‹D$$‹\$4‰\$‹\$8‰\$‰D$‰$‰L$‹YÿÓ‹L$‹D$‰L$<‰D$@ƒÄÃè    ëÌÌÌÌÌÌÌÌÌÌÌÌÌ      Œ       º  0runtime.morestack_noctxt   H8  
"crypto/elliptic.y @$type.*math/big.Int "crypto/elliptic.x 8$type.*math/big.Int $crypto/elliptic.y1 0$type.*math/big.Int $crypto/elliptic.x1 ($type.*math/big.Int ""..this  $type."".PrivateKey 8L7 p "p 
 F* TgclocalsÂ·f73b10702d2d415b96cccabf713539c3 TgclocalsÂ·23e8278e2b69a3a75fa59b23c49ed6ad   <autogenerated>ş4"".(*PrivateKey).IsOnCurve à  àe‹    ;avSƒì‹Y…Ût
|$9;u‰#‹\$ƒû t2‹‹k‹\$ ‰\$‹\$$‰\$‰l$‰,$‰L$‹YÿÓ¶\$ˆ\$(ƒÄÃ‰ëÊè    ëšÌÌÌÌÌÌÌÌÌÌ      ˜       À  0runtime.morestack_noctxt    0  "".~r3 type.bool "crypto/elliptic.y $type.*math/big.Int "crypto/elliptic.x $type.*math/big.Int ""..this  &type.*"".PrivateKey 0K/0/ p $p 
 L$ TgclocalsÂ·e5d5edcf53e2c122038779d75a487a60 TgclocalsÂ·23e8278e2b69a3a75fa59b23c49ed6ad   <autogenerated>ş."".PrivateKey.IsOnCurve À  Àe‹    ;avIƒì‹Y…Ût
|$9;u‰#‹L$‹D$ ‹\$0‰\$‹\$4‰\$‰D$‰$‰L$‹YÿÓ¶\$ˆ\$8ƒÄÃè    ë¤ÌÌÌÌ      Œ       ¬  0runtime.morestack_noctxt   @0  "".~r3 8type.bool "crypto/elliptic.y 0$type.*math/big.Int "crypto/elliptic.x ($type.*math/big.Int ""..this  $type."".PrivateKey 0E/ ` &` 
 F TgclocalsÂ·ec7b4b73635f43711b7a725505b4bf2f TgclocalsÂ·23e8278e2b69a3a75fa59b23c49ed6ad   <autogenerated>ş."".(*PrivateKey).Params À  Àe‹    ;avBƒì‹Y…Ût
|$9;u‰#‹\$ƒû t!‹‹k‰l$‰,$‰L$‹Y ÿÓ‹\$‰\$ƒÄÃ‰ëÛè    ë«ÌÌÌÌÌÌÌÌÌÌÌ      x         0runtime.morestack_noctxt      "".~r1 Btype.*crypto/elliptic.CurveParams ""..this  &type.*"".PrivateKey  :  ` (` 
 <$ TgclocalsÂ·3f5c1f818fa7055d0400cecd34057162 TgclocalsÂ·23e8278e2b69a3a75fa59b23c49ed6ad   <autogenerated>ş("".PrivateKey.Params     e‹    ;av8ƒì‹Y…Ût
|$9;u‰#‹L$‹D$‰D$‰$‰L$‹Y ÿÓ‹\$‰\$(ƒÄÃè    ëµÌÌÌÌÌ      l       Š  0runtime.morestack_noctxt   0   "".~r1 (Btype.*crypto/elliptic.CurveParams ""..this  $type."".PrivateKey  4 P *P 
 6 TgclocalsÂ·f0c364a62493c61af71404840d80ebfa TgclocalsÂ·23e8278e2b69a3a75fa59b23c49ed6ad   <autogenerated>ş>"".(*PrivateKey).ScalarBaseMult €  €e‹    ;avbƒì ‹Y…Ût
|$$9;u‰#‹\$$ƒû tA‹‹k‹\$(‰\$‹\$,‰\$‹\$0‰\$‰l$‰,$‰L$‹Y$ÿÓ‹L$‹D$‰L$4‰D$8ƒÄ Ã‰ë»è    ë‹ÌÌÌÌÌÌÌÌÌÌÌ      ¨       Ş  0runtime.morestack_noctxt   0@  "crypto/elliptic.y ($type.*math/big.Int "crypto/elliptic.x  $type.*math/big.Int "crypto/elliptic.k type.[]uint8 ""..this  &type.*"".PrivateKey @Z?@? € ,€ 
 T, TgclocalsÂ·d98f60bd8519d0c68364b2a1d83af357 TgclocalsÂ·23e8278e2b69a3a75fa59b23c49ed6ad   <autogenerated>ş8"".PrivateKey.ScalarBaseMult à  àe‹    ;avXƒì ‹Y…Ût
|$$9;u‰#‹L$$‹D$(‹\$8‰\$‹\$<‰\$‹\$@‰\$‰D$‰$‰L$‹Y$ÿÓ‹L$‹D$‰L$D‰D$HƒÄ Ãè    ë•ÌÌÌÌÌ      œ       Ê  0runtime.morestack_noctxt   P@  "crypto/elliptic.y H$type.*math/big.Int "crypto/elliptic.x @$type.*math/big.Int "crypto/elliptic.k (type.[]uint8 ""..this  $type."".PrivateKey @T? p .p 
 N" TgclocalsÂ·66fb4c7ebad2133d33206497b98b11d3 TgclocalsÂ·23e8278e2b69a3a75fa59b23c49ed6ad   <autogenerated>ş6"".(*PrivateKey).ScalarMult     e‹    ;avrƒì(‹Y…Ût
|$,9;u‰#‹\$,ƒû tQ‹‹k‹\$0‰\$‹\$4‰\$‹\$8‰\$‹\$<‰\$‹\$@‰\$‰l$$‰,$‰L$ ‹Y(ÿÓ‹L$‹D$‰L$D‰D$HƒÄ(Ã‰ë«è    éxÿÿÿÌÌÌÌÌÌÌÌ      È       ş  0runtime.morestack_noctxt   @P  "crypto/elliptic.y 8$type.*math/big.Int "crypto/elliptic.x 0$type.*math/big.Int "crypto/elliptic.k type.[]uint8 $crypto/elliptic.y1 $type.*math/big.Int $crypto/elliptic.x1 $type.*math/big.Int ""..this  &type.*"".PrivateKey PjOPO  0 
 d, TgclocalsÂ·ecc591e57c9cfd5780396a91917d5274 TgclocalsÂ·23e8278e2b69a3a75fa59b23c49ed6ad   <autogenerated>ş0"".PrivateKey.ScalarMult €  €e‹    ;avhƒì(‹Y…Ût
|$,9;u‰#‹L$,‹D$0‹\$@‰\$‹\$D‰\$‹\$H‰\$‹\$L‰\$‹\$P‰\$‰D$$‰$‰L$ ‹Y(ÿÓ‹L$‹D$‰L$T‰D$XƒÄ(Ãè    ë…ÌÌÌÌÌ      ¼       ê  0runtime.morestack_noctxt   `P  "crypto/elliptic.y X$type.*math/big.Int "crypto/elliptic.x P$type.*math/big.Int "crypto/elliptic.k 8type.[]uint8 $crypto/elliptic.y1 0$type.*math/big.Int $crypto/elliptic.x1 ($type.*math/big.Int ""..this  $type."".PrivateKey PdO € 2€ 
 ^" TgclocalsÂ·4fa86d4dd464bd6bc79c36e165c2cea9 TgclocalsÂ·23e8278e2b69a3a75fa59b23c49ed6ad   <autogenerated>ş*"".invertible.Inverse     e‹    ;av8ƒì‹Y…Ût
|$9;u‰#‹\$‰\$‹\$‰$‹\$‹[ÿÓ‹\$‰\$ƒÄÃè    ëµÌÌÌÌÌ      l       Š  0runtime.morestack_noctxt      "".~r1 $type.*math/big.Int "".k $type.*math/big.Int ""..this  $type."".invertible 4 P 4P 
 6 TgclocalsÂ·e5d5edcf53e2c122038779d75a487a60 TgclocalsÂ·33cdeccccebe80329f1fdbee7f5874cb   <autogenerated>ş8"".combinedMult.CombinedMult     e‹    ;avxƒì,‹Y…Ût
|$09;u‰#‹\$8‰\$‹\$<‰\$‹\$@‰\$‹\$D‰\$‹\$H‰\$‹\$L‰\$‹\$P‰\$‹\$T‰\$ ‹\$4‰$‹\$0‹[ÿÓ‹L$$‹D$(‰L$X‰D$\ƒÄ,Ãè    érÿÿÿÌÌ      Ü       Š  0runtime.morestack_noctxt   `X  "".y X$type.*math/big.Int "".x P$type.*math/big.Int "".scalar 8type.[]uint8 "".baseScalar  type.[]uint8 "".bigY $type.*math/big.Int "".bigX $type.*math/big.Int ""..this  (type."".combinedMult XtW  6 
 n" TgclocalsÂ·3a4457348598b5a434e53329773b7b05 TgclocalsÂ·33cdeccccebe80329f1fdbee7f5874cb   <autogenerated>şTgclocalsÂ·33cdeccccebe80329f1fdbee7f5874cb           şTgclocalsÂ·0b86ef39f3fed835f14ba5f4d7c62fa2             şTgclocalsÂ·2c78d3ad9d760b5f66e2e47be684c787                   şTgclocalsÂ·2c3c751f5a9f71ad83dad407bc98598a           Ï   Ï    şTgclocalsÂ·6eb3d79136cbc4fbd79b029239cb7789 H  H                               şTgclocalsÂ·c5be8ba0fa1d10f0bd8ec3798363f251 H  H                  o   o       şTgclocalsÂ·cc403846fece7fb9a38907287267745a @  @                            şTgclocalsÂ·c3e8ad084447b3db377723b14ca5e3b3 @  @            o             şTgclocalsÂ·0c8aa8e80191a30eac23f1a218103f16                   şTgclocalsÂ·ac69ed8bba674801fdf4bb781f82cfa6                  şTgclocalsÂ·0a505ec66736deb2f34fa0d910d79932 (  (                 şTgclocalsÂ·9c91d8a91ac42440a3d1507bc8d2e808 (  (                ş>0go.itab.*"".zr.io.Reader     ş>Xgo.itab.crypto/cipher.StreamReader.io.Reader     ş@go.string.hdr."IV for ECDSA CTR"             8go.string."IV for ECDSA CTR"   ş8go.string."IV for ECDSA CTR" (  "IV for ECDSA CTR  şTgclocalsÂ·a1df2b8bd226f90ce1ff0c3be7aef311 °  °   %                     €       €     0 €     0                        à     à    à   
à   
 à   	 à   	 à   	 à    à    à    şTgclocalsÂ·4ec6022d7a8ad5c13bf62802871a1f5c        
      Ï   Ï                                 Ï  O  O  Ï   şTgclocalsÂ·f29d36ab78ed428bc5e044f7c7b1d471 ˜  ˜           0 €0 À0À0 ˆ0 ¨0  0 °0 °ğ  € €  0 ƒ0       şTgclocalsÂ·37e27975c5fdaa0f8e0e6013a5b8e19b ˜  ˜      3   3   3   3   3   3   3   3   3   3   3   3   3   3   3   3   3    şTgclocalsÂ·33cdeccccebe80329f1fdbee7f5874cb           şTgclocalsÂ·b60dc0a6046c556b02baa766a3fd5a27             şTgclocalsÂ·33cdeccccebe80329f1fdbee7f5874cb           şTgclocalsÂ·33cdeccccebe80329f1fdbee7f5874cb           ş<"".one  $type.*math/big.Int   ş<"".zeroReader  type.*"".zr        """.statictmp_0104   ş<""".statictmp_0104  type."".zr   ş>"".initdoneÂ·  type.uint8   ş4"".(*PrivateKey).PublicÂ·f          ."".(*PrivateKey).Public   ş0"".(*PrivateKey).SignÂ·f          *"".(*PrivateKey).Sign   ş,"".randFieldElementÂ·f          &"".randFieldElement   ş""".GenerateKeyÂ·f          "".GenerateKey   ş"".hashToIntÂ·f          "".hashToInt   ş&"".fermatInverseÂ·f           "".fermatInverse   ş"".SignÂ·f          "".Sign   ş"".VerifyÂ·f          "".Verify   ş "".(*zr).ReadÂ·f          "".(*zr).Read   ş"".initÂ·f          "".init   şTgclocalsÂ·33cdeccccebe80329f1fdbee7f5874cb           şTgclocalsÂ·0b86ef39f3fed835f14ba5f4d7c62fa2             şTgclocalsÂ·a8eabfc4a4514ed6b3b0c61e9680e440              şTgclocalsÂ·3bb21ca8fe1d99a3e492463bd711418a             ş6type..hashfunc."".PublicKey          .type..hash."".PublicKey   ş2type..eqfunc."".PublicKey          *type..eq."".PublicKey   ş,type..alg."".PublicKey              6type..hashfunc."".PublicKey     2type..eqfunc."".PublicKey   ş"runtime.gcbits.0f    ş>go.string.hdr."ecdsa.PublicKey"             6go.string."ecdsa.PublicKey"   ş6go.string."ecdsa.PublicKey"     ecdsa.PublicKey  ş"go.string.hdr."X"             go.string."X"   şgo.string."X"   X  ş"go.string.hdr."Y"             go.string."Y"   şgo.string."Y"   Y  şTgclocalsÂ·23e8278e2b69a3a75fa59b23c49ed6ad              şTgclocalsÂ·3f3273e6cb8b40c41344569cdb3bf5df             şTgclocalsÂ·23e8278e2b69a3a75fa59b23c49ed6ad              şTgclocalsÂ·71661cbbb3aac01ffff82ab01d45fbb8      
   ÿ    şTgclocalsÂ·23e8278e2b69a3a75fa59b23c49ed6ad              şTgclocalsÂ·13bdb4aeeaf63de3cc223d640262ea59             şTgclocalsÂ·23e8278e2b69a3a75fa59b23c49ed6ad              şTgclocalsÂ·cde59c54593d9a88e8be0b1914f1516e         ?    şTgclocalsÂ·23e8278e2b69a3a75fa59b23c49ed6ad              şTgclocalsÂ·e5d5edcf53e2c122038779d75a487a60             şTgclocalsÂ·23e8278e2b69a3a75fa59b23c49ed6ad              şTgclocalsÂ·d01b73eb76ffa8f00887520b327d3aa3         ?    şTgclocalsÂ·23e8278e2b69a3a75fa59b23c49ed6ad              şTgclocalsÂ·3f5c1f818fa7055d0400cecd34057162             şTgclocalsÂ·23e8278e2b69a3a75fa59b23c49ed6ad              şTgclocalsÂ·d0110d631ecd4af0947009e36d46dc99             şTgclocalsÂ·23e8278e2b69a3a75fa59b23c49ed6ad              şTgclocalsÂ·d98f60bd8519d0c68364b2a1d83af357             şTgclocalsÂ·23e8278e2b69a3a75fa59b23c49ed6ad              şTgclocalsÂ·01bc52eaf25414f97ebedc96f60fbb43      	       şTgclocalsÂ·23e8278e2b69a3a75fa59b23c49ed6ad              şTgclocalsÂ·ecc591e57c9cfd5780396a91917d5274             şTgclocalsÂ·23e8278e2b69a3a75fa59b23c49ed6ad              şTgclocalsÂ·9423f8cc2bff62b1506ceac7285779a8             ş"runtime.gcbits.01    şÄgo.string.hdr."func(ecdsa.PublicKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)"       R      ¼go.string."func(ecdsa.PublicKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)"   ş¼go.string."func(ecdsa.PublicKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)" ¨  ¦func(ecdsa.PublicKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)  şätype.func("".PublicKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int) ¸  ¸      ôgİz 3                                                                         °  runtime.algarray   (  "runtime.gcbits.01   0  Ägo.string.hdr."func(ecdsa.PublicKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)"   @  ögo.weak.type.*func("".PublicKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   P€ ätype.func("".PublicKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   h¨ ätype.func("".PublicKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   €  "type."".PublicKey   ˆ  $type.*math/big.Int     $type.*math/big.Int   ˜  $type.*math/big.Int      $type.*math/big.Int   ¨  $type.*math/big.Int   °  $type.*math/big.Int   ş˜go.typelink.func(ecdsa.PublicKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)	func("".PublicKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)          ätype.func("".PublicKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   şœgo.string.hdr."func(ecdsa.PublicKey, *big.Int, *big.Int) (*big.Int, *big.Int)"       >      ”go.string."func(ecdsa.PublicKey, *big.Int, *big.Int) (*big.Int, *big.Int)"   ş”go.string."func(ecdsa.PublicKey, *big.Int, *big.Int) (*big.Int, *big.Int)" €  ~func(ecdsa.PublicKey, *big.Int, *big.Int) (*big.Int, *big.Int)  ş¨type.func("".PublicKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int) ¨  ¨      º|¶ù 3                                                                 °  runtime.algarray   (  "runtime.gcbits.01   0  œgo.string.hdr."func(ecdsa.PublicKey, *big.Int, *big.Int) (*big.Int, *big.Int)"   @  ºgo.weak.type.*func("".PublicKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   P€ ¨type.func("".PublicKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   h˜ ¨type.func("".PublicKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   €  "type."".PublicKey   ˆ  $type.*math/big.Int     $type.*math/big.Int   ˜  $type.*math/big.Int      $type.*math/big.Int   ş´go.typelink.func(ecdsa.PublicKey, *big.Int, *big.Int) (*big.Int, *big.Int)	func("".PublicKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)          ¨type.func("".PublicKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   ş|go.string.hdr."func(ecdsa.PublicKey, *big.Int, *big.Int) bool"       .      tgo.string."func(ecdsa.PublicKey, *big.Int, *big.Int) bool"   ştgo.string."func(ecdsa.PublicKey, *big.Int, *big.Int) bool" `  ^func(ecdsa.PublicKey, *big.Int, *big.Int) bool  şttype.func("".PublicKey, *math/big.Int, *math/big.Int) bool           Å 3                                                             °  runtime.algarray   (  "runtime.gcbits.01   0  |go.string.hdr."func(ecdsa.PublicKey, *big.Int, *big.Int) bool"   @  †go.weak.type.*func("".PublicKey, *math/big.Int, *math/big.Int) bool   P€ ttype.func("".PublicKey, *math/big.Int, *math/big.Int) bool   h˜ ttype.func("".PublicKey, *math/big.Int, *math/big.Int) bool   €  "type."".PublicKey   ˆ  $type.*math/big.Int     $type.*math/big.Int   ˜  type.bool   şàgo.typelink.func(ecdsa.PublicKey, *big.Int, *big.Int) bool	func("".PublicKey, *math/big.Int, *math/big.Int) bool          ttype.func("".PublicKey, *math/big.Int, *math/big.Int) bool   şvgo.string.hdr."func(ecdsa.PublicKey) *elliptic.CurveParams"       +      ngo.string."func(ecdsa.PublicKey) *elliptic.CurveParams"   şngo.string."func(ecdsa.PublicKey) *elliptic.CurveParams" X  Xfunc(ecdsa.PublicKey) *elliptic.CurveParams  şhtype.func("".PublicKey) *crypto/elliptic.CurveParams         ¶ñÓ± 3                                                     °  runtime.algarray   (  "runtime.gcbits.01   0  vgo.string.hdr."func(ecdsa.PublicKey) *elliptic.CurveParams"   @  zgo.weak.type.*func("".PublicKey) *crypto/elliptic.CurveParams   P€ htype.func("".PublicKey) *crypto/elliptic.CurveParams   hˆ htype.func("".PublicKey) *crypto/elliptic.CurveParams   €  "type."".PublicKey   ˆ  Btype.*crypto/elliptic.CurveParams   şÎgo.typelink.func(ecdsa.PublicKey) *elliptic.CurveParams	func("".PublicKey) *crypto/elliptic.CurveParams          htype.func("".PublicKey) *crypto/elliptic.CurveParams   ş.go.string.hdr."[]uint8"             &go.string."[]uint8"   ş&go.string."[]uint8"   []uint8  ştype.[]uint8 P  P      ß~.8                         
   runtime.algarray   (  "runtime.gcbits.01   0  .go.string.hdr."[]uint8"   @  *go.weak.type.*[]uint8   H  type.uint8   ş6go.typelink.[]uint8	[]uint8          type.[]uint8   ş†go.string.hdr."func(ecdsa.PublicKey, []uint8) (*big.Int, *big.Int)"       3      ~go.string."func(ecdsa.PublicKey, []uint8) (*big.Int, *big.Int)"   ş~go.string."func(ecdsa.PublicKey, []uint8) (*big.Int, *big.Int)" h  hfunc(ecdsa.PublicKey, []uint8) (*big.Int, *big.Int)  ş~type.func("".PublicKey, []uint8) (*math/big.Int, *math/big.Int)           g«¿ 3                                                             °  runtime.algarray   (  "runtime.gcbits.01   0  †go.string.hdr."func(ecdsa.PublicKey, []uint8) (*big.Int, *big.Int)"   @  go.weak.type.*func("".PublicKey, []uint8) (*math/big.Int, *math/big.Int)   P€ ~type.func("".PublicKey, []uint8) (*math/big.Int, *math/big.Int)   h ~type.func("".PublicKey, []uint8) (*math/big.Int, *math/big.Int)   €  "type."".PublicKey   ˆ  type.[]uint8     $type.*math/big.Int   ˜  $type.*math/big.Int   şôgo.typelink.func(ecdsa.PublicKey, []uint8) (*big.Int, *big.Int)	func("".PublicKey, []uint8) (*math/big.Int, *math/big.Int)          ~type.func("".PublicKey, []uint8) (*math/big.Int, *math/big.Int)   ş®go.string.hdr."func(ecdsa.PublicKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)"       G      ¦go.string."func(ecdsa.PublicKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)"   ş¦go.string."func(ecdsa.PublicKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)"   func(ecdsa.PublicKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)  şºtype.func("".PublicKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int) °  °       “Rg 3                                                                     °  runtime.algarray   (  "runtime.gcbits.01   0  ®go.string.hdr."func(ecdsa.PublicKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)"   @  Ìgo.weak.type.*func("".PublicKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   P€ ºtype.func("".PublicKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   h  ºtype.func("".PublicKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   €  "type."".PublicKey   ˆ  $type.*math/big.Int     $type.*math/big.Int   ˜  type.[]uint8      $type.*math/big.Int   ¨  $type.*math/big.Int   şØgo.typelink.func(ecdsa.PublicKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)	func("".PublicKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)          ºtype.func("".PublicKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   ş2go.string.hdr."PublicKey"       	      *go.string."PublicKey"   ş*go.string."PublicKey"   PublicKey  ş8go.string.hdr."crypto/ecdsa"             0go.string."crypto/ecdsa"   ş0go.string."crypto/ecdsa"    crypto/ecdsa  ş"go.importpath."".             0go.string."crypto/ecdsa"   ş&go.string.hdr."Add"             go.string."Add"   şgo.string."Add"   Add  ş¢go.string.hdr."func(*big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)"       A      šgo.string."func(*big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)"   şšgo.string."func(*big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)" ˆ  „func(*big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)  şÈtype.func(*math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int) °  °      ğ\áõ 3                                                                     °  runtime.algarray   (  "runtime.gcbits.01   0  ¢go.string.hdr."func(*big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)"   @  Úgo.weak.type.*func(*math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   P€ Ètype.func(*math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   h  Ètype.func(*math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   €  $type.*math/big.Int   ˆ  $type.*math/big.Int     $type.*math/big.Int   ˜  $type.*math/big.Int      $type.*math/big.Int   ¨  $type.*math/big.Int   şÚgo.typelink.func(*big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)	func(*math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)          Ètype.func(*math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   ş,go.string.hdr."Double"             $go.string."Double"   ş$go.string."Double"   Double  şzgo.string.hdr."func(*big.Int, *big.Int) (*big.Int, *big.Int)"       -      rgo.string."func(*big.Int, *big.Int) (*big.Int, *big.Int)"   şrgo.string."func(*big.Int, *big.Int) (*big.Int, *big.Int)" `  \func(*big.Int, *big.Int) (*big.Int, *big.Int)  şŒtype.func(*math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)           3`1
 3                                                             °  runtime.algarray   (  "runtime.gcbits.01   0  zgo.string.hdr."func(*big.Int, *big.Int) (*big.Int, *big.Int)"   @  go.weak.type.*func(*math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   P€ Œtype.func(*math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   h Œtype.func(*math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   €  $type.*math/big.Int   ˆ  $type.*math/big.Int     $type.*math/big.Int   ˜  $type.*math/big.Int   şögo.typelink.func(*big.Int, *big.Int) (*big.Int, *big.Int)	func(*math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)          Œtype.func(*math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   ş2go.string.hdr."IsOnCurve"       	      *go.string."IsOnCurve"   ş*go.string."IsOnCurve"   IsOnCurve  şZgo.string.hdr."func(*big.Int, *big.Int) bool"             Rgo.string."func(*big.Int, *big.Int) bool"   şRgo.string."func(*big.Int, *big.Int) bool" @  <func(*big.Int, *big.Int) bool  şXtype.func(*math/big.Int, *math/big.Int) bool ˜  ˜      À§ 3                                                         °  runtime.algarray   (  "runtime.gcbits.01   0  Zgo.string.hdr."func(*big.Int, *big.Int) bool"   @  jgo.weak.type.*func(*math/big.Int, *math/big.Int) bool   P€ Xtype.func(*math/big.Int, *math/big.Int) bool   h Xtype.func(*math/big.Int, *math/big.Int) bool   €  $type.*math/big.Int   ˆ  $type.*math/big.Int     type.bool   ş¢go.typelink.func(*big.Int, *big.Int) bool	func(*math/big.Int, *math/big.Int) bool          Xtype.func(*math/big.Int, *math/big.Int) bool   ş,go.string.hdr."Params"             $go.string."Params"   ş$go.string."Params"   Params  şXgo.string.hdr."func() *elliptic.CurveParams"             Pgo.string."func() *elliptic.CurveParams"   şPgo.string."func() *elliptic.CurveParams" @  :func() *elliptic.CurveParams  şPtype.func() *crypto/elliptic.CurveParams ˆ  ˆ      ˆ¨"å 3                                                   °  runtime.algarray   (  "runtime.gcbits.01   0  Xgo.string.hdr."func() *elliptic.CurveParams"   @  bgo.weak.type.*func() *crypto/elliptic.CurveParams   P€ Ptype.func() *crypto/elliptic.CurveParams   h€ Ptype.func() *crypto/elliptic.CurveParams   €  Btype.*crypto/elliptic.CurveParams   ş˜go.typelink.func() *elliptic.CurveParams	func() *crypto/elliptic.CurveParams          Ptype.func() *crypto/elliptic.CurveParams   ş<go.string.hdr."ScalarBaseMult"             4go.string."ScalarBaseMult"   ş4go.string."ScalarBaseMult"    ScalarBaseMult  şdgo.string.hdr."func([]uint8) (*big.Int, *big.Int)"       "      \go.string."func([]uint8) (*big.Int, *big.Int)"   ş\go.string."func([]uint8) (*big.Int, *big.Int)" H  Ffunc([]uint8) (*big.Int, *big.Int)  şbtype.func([]uint8) (*math/big.Int, *math/big.Int) ˜  ˜      €Ÿ.l 3                                                         °  runtime.algarray   (  "runtime.gcbits.01   0  dgo.string.hdr."func([]uint8) (*big.Int, *big.Int)"   @  tgo.weak.type.*func([]uint8) (*math/big.Int, *math/big.Int)   P€ btype.func([]uint8) (*math/big.Int, *math/big.Int)   hˆ btype.func([]uint8) (*math/big.Int, *math/big.Int)   €  type.[]uint8   ˆ  $type.*math/big.Int     $type.*math/big.Int   ş¶go.typelink.func([]uint8) (*big.Int, *big.Int)	func([]uint8) (*math/big.Int, *math/big.Int)          btype.func([]uint8) (*math/big.Int, *math/big.Int)   ş4go.string.hdr."ScalarMult"       
      ,go.string."ScalarMult"   ş,go.string."ScalarMult"   ScalarMult  şŒgo.string.hdr."func(*big.Int, *big.Int, []uint8) (*big.Int, *big.Int)"       6      „go.string."func(*big.Int, *big.Int, []uint8) (*big.Int, *big.Int)"   ş„go.string."func(*big.Int, *big.Int, []uint8) (*big.Int, *big.Int)" p  nfunc(*big.Int, *big.Int, []uint8) (*big.Int, *big.Int)  ştype.func(*math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int) ¨  ¨      ašÙÂ 3                                                                 °  runtime.algarray   (  "runtime.gcbits.01   0  Œgo.string.hdr."func(*big.Int, *big.Int, []uint8) (*big.Int, *big.Int)"   @  °go.weak.type.*func(*math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   P€ type.func(*math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   h˜ type.func(*math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   €  $type.*math/big.Int   ˆ  $type.*math/big.Int     type.[]uint8   ˜  $type.*math/big.Int      $type.*math/big.Int   şšgo.typelink.func(*big.Int, *big.Int, []uint8) (*big.Int, *big.Int)	func(*math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)          type.func(*math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   ş"type."".PublicKey            ™ÉZN                                                                                                                                                                                                                                                           X   ,type..alg."".PublicKey   (  "runtime.gcbits.0f   0  >go.string.hdr."ecdsa.PublicKey"   @  $type.*"".PublicKey   H` "type."".PublicKey   p  4type.crypto/elliptic.Curve   ˆ  "go.string.hdr."X"   ˜  $type.*math/big.Int   °  "go.string.hdr."Y"   À  $type.*math/big.Int   8Ø "type."".PublicKey   Ø  2go.string.hdr."PublicKey"   à  "go.importpath."".   è€ "type."".PublicKey   €  &go.string.hdr."Add"     Ètype.func(*math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   ˜  ätype.func("".PublicKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)      &"".(*PublicKey).Add   ¨   "".PublicKey.Add   °  ,go.string.hdr."Double"   À  Œtype.func(*math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   È  ¨type.func("".PublicKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   Ğ  ,"".(*PublicKey).Double   Ø  &"".PublicKey.Double   à  2go.string.hdr."IsOnCurve"   ğ  Xtype.func(*math/big.Int, *math/big.Int) bool   ø  ttype.func("".PublicKey, *math/big.Int, *math/big.Int) bool   €  2"".(*PublicKey).IsOnCurve   ˆ  ,"".PublicKey.IsOnCurve     ,go.string.hdr."Params"      Ptype.func() *crypto/elliptic.CurveParams   ¨  htype.func("".PublicKey) *crypto/elliptic.CurveParams   °  ,"".(*PublicKey).Params   ¸  &"".PublicKey.Params   À  <go.string.hdr."ScalarBaseMult"   Ğ  btype.func([]uint8) (*math/big.Int, *math/big.Int)   Ø  ~type.func("".PublicKey, []uint8) (*math/big.Int, *math/big.Int)   à  <"".(*PublicKey).ScalarBaseMult   è  6"".PublicKey.ScalarBaseMult   ğ  4go.string.hdr."ScalarMult"   €  type.func(*math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   ˆ  ºtype.func("".PublicKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)     4"".(*PublicKey).ScalarMult   ˜  ."".PublicKey.ScalarMult   ş@go.string.hdr."*ecdsa.PublicKey"             8go.string."*ecdsa.PublicKey"   ş8go.string."*ecdsa.PublicKey" (  "*ecdsa.PublicKey  şÆgo.string.hdr."func(*ecdsa.PublicKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)"       S      ¾go.string."func(*ecdsa.PublicKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)"   ş¾go.string."func(*ecdsa.PublicKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)" ¨  ¨func(*ecdsa.PublicKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)  şætype.func(*"".PublicKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int) ¸  ¸      ²% • 3                                                                         °  runtime.algarray   (  "runtime.gcbits.01   0  Ægo.string.hdr."func(*ecdsa.PublicKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)"   @  øgo.weak.type.*func(*"".PublicKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   P€ ætype.func(*"".PublicKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   h¨ ætype.func(*"".PublicKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   €  $type.*"".PublicKey   ˆ  $type.*math/big.Int     $type.*math/big.Int   ˜  $type.*math/big.Int      $type.*math/big.Int   ¨  $type.*math/big.Int   °  $type.*math/big.Int   şœgo.typelink.func(*ecdsa.PublicKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)	func(*"".PublicKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)          ætype.func(*"".PublicKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   şgo.string.hdr."func(*ecdsa.PublicKey, *big.Int, *big.Int) (*big.Int, *big.Int)"       ?      –go.string."func(*ecdsa.PublicKey, *big.Int, *big.Int) (*big.Int, *big.Int)"   ş–go.string."func(*ecdsa.PublicKey, *big.Int, *big.Int) (*big.Int, *big.Int)" €  €func(*ecdsa.PublicKey, *big.Int, *big.Int) (*big.Int, *big.Int)  şªtype.func(*"".PublicKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int) ¨  ¨      ö&‡? 3                                                                 °  runtime.algarray   (  "runtime.gcbits.01   0  go.string.hdr."func(*ecdsa.PublicKey, *big.Int, *big.Int) (*big.Int, *big.Int)"   @  ¼go.weak.type.*func(*"".PublicKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   P€ ªtype.func(*"".PublicKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   h˜ ªtype.func(*"".PublicKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   €  $type.*"".PublicKey   ˆ  $type.*math/big.Int     $type.*math/big.Int   ˜  $type.*math/big.Int      $type.*math/big.Int   ş¸go.typelink.func(*ecdsa.PublicKey, *big.Int, *big.Int) (*big.Int, *big.Int)	func(*"".PublicKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)          ªtype.func(*"".PublicKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   ş~go.string.hdr."func(*ecdsa.PublicKey, *big.Int, *big.Int) bool"       /      vgo.string."func(*ecdsa.PublicKey, *big.Int, *big.Int) bool"   şvgo.string."func(*ecdsa.PublicKey, *big.Int, *big.Int) bool" `  `func(*ecdsa.PublicKey, *big.Int, *big.Int) bool  şvtype.func(*"".PublicKey, *math/big.Int, *math/big.Int) bool           ›²N¢ 3                                                             °  runtime.algarray   (  "runtime.gcbits.01   0  ~go.string.hdr."func(*ecdsa.PublicKey, *big.Int, *big.Int) bool"   @  ˆgo.weak.type.*func(*"".PublicKey, *math/big.Int, *math/big.Int) bool   P€ vtype.func(*"".PublicKey, *math/big.Int, *math/big.Int) bool   h˜ vtype.func(*"".PublicKey, *math/big.Int, *math/big.Int) bool   €  $type.*"".PublicKey   ˆ  $type.*math/big.Int     $type.*math/big.Int   ˜  type.bool   şägo.typelink.func(*ecdsa.PublicKey, *big.Int, *big.Int) bool	func(*"".PublicKey, *math/big.Int, *math/big.Int) bool          vtype.func(*"".PublicKey, *math/big.Int, *math/big.Int) bool   şxgo.string.hdr."func(*ecdsa.PublicKey) *elliptic.CurveParams"       ,      pgo.string."func(*ecdsa.PublicKey) *elliptic.CurveParams"   şpgo.string."func(*ecdsa.PublicKey) *elliptic.CurveParams" `  Zfunc(*ecdsa.PublicKey) *elliptic.CurveParams  şjtype.func(*"".PublicKey) *crypto/elliptic.CurveParams         Zmdš 3                                                     °  runtime.algarray   (  "runtime.gcbits.01   0  xgo.string.hdr."func(*ecdsa.PublicKey) *elliptic.CurveParams"   @  |go.weak.type.*func(*"".PublicKey) *crypto/elliptic.CurveParams   P€ jtype.func(*"".PublicKey) *crypto/elliptic.CurveParams   hˆ jtype.func(*"".PublicKey) *crypto/elliptic.CurveParams   €  $type.*"".PublicKey   ˆ  Btype.*crypto/elliptic.CurveParams   şÒgo.typelink.func(*ecdsa.PublicKey) *elliptic.CurveParams	func(*"".PublicKey) *crypto/elliptic.CurveParams          jtype.func(*"".PublicKey) *crypto/elliptic.CurveParams   şˆgo.string.hdr."func(*ecdsa.PublicKey, []uint8) (*big.Int, *big.Int)"       4      €go.string."func(*ecdsa.PublicKey, []uint8) (*big.Int, *big.Int)"   ş€go.string."func(*ecdsa.PublicKey, []uint8) (*big.Int, *big.Int)" p  jfunc(*ecdsa.PublicKey, []uint8) (*big.Int, *big.Int)  ş€type.func(*"".PublicKey, []uint8) (*math/big.Int, *math/big.Int)           3nÄ7 3                                                             °  runtime.algarray   (  "runtime.gcbits.01   0  ˆgo.string.hdr."func(*ecdsa.PublicKey, []uint8) (*big.Int, *big.Int)"   @  ’go.weak.type.*func(*"".PublicKey, []uint8) (*math/big.Int, *math/big.Int)   P€ €type.func(*"".PublicKey, []uint8) (*math/big.Int, *math/big.Int)   h €type.func(*"".PublicKey, []uint8) (*math/big.Int, *math/big.Int)   €  $type.*"".PublicKey   ˆ  type.[]uint8     $type.*math/big.Int   ˜  $type.*math/big.Int   şøgo.typelink.func(*ecdsa.PublicKey, []uint8) (*big.Int, *big.Int)	func(*"".PublicKey, []uint8) (*math/big.Int, *math/big.Int)          €type.func(*"".PublicKey, []uint8) (*math/big.Int, *math/big.Int)   ş°go.string.hdr."func(*ecdsa.PublicKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)"       H      ¨go.string."func(*ecdsa.PublicKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)"   ş¨go.string."func(*ecdsa.PublicKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)" ˜  ’func(*ecdsa.PublicKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)  ş¼type.func(*"".PublicKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int) °  °      fy< 3                                                                     °  runtime.algarray   (  "runtime.gcbits.01   0  °go.string.hdr."func(*ecdsa.PublicKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)"   @  Îgo.weak.type.*func(*"".PublicKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   P€ ¼type.func(*"".PublicKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   h  ¼type.func(*"".PublicKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   €  $type.*"".PublicKey   ˆ  $type.*math/big.Int     $type.*math/big.Int   ˜  type.[]uint8      $type.*math/big.Int   ¨  $type.*math/big.Int   şÜgo.typelink.func(*ecdsa.PublicKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)	func(*"".PublicKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)          ¼type.func(*"".PublicKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   ş$type.*"".PublicKey  ˜  ˜      €Ğ/ 6                                                                                                                                                                                          J @  runtime.algarray   (  "runtime.gcbits.01   0  @go.string.hdr."*ecdsa.PublicKey"   @  6go.weak.type.**"".PublicKey   H  "type."".PublicKey   8P $type.*"".PublicKey   `x $type.*"".PublicKey   x  &go.string.hdr."Add"   ˆ  Ètype.func(*math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)     ætype.func(*"".PublicKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   ˜  &"".(*PublicKey).Add      &"".(*PublicKey).Add   ¨  ,go.string.hdr."Double"   ¸  Œtype.func(*math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   À  ªtype.func(*"".PublicKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   È  ,"".(*PublicKey).Double   Ğ  ,"".(*PublicKey).Double   Ø  2go.string.hdr."IsOnCurve"   è  Xtype.func(*math/big.Int, *math/big.Int) bool   ğ  vtype.func(*"".PublicKey, *math/big.Int, *math/big.Int) bool   ø  2"".(*PublicKey).IsOnCurve   €  2"".(*PublicKey).IsOnCurve   ˆ  ,go.string.hdr."Params"   ˜  Ptype.func() *crypto/elliptic.CurveParams      jtype.func(*"".PublicKey) *crypto/elliptic.CurveParams   ¨  ,"".(*PublicKey).Params   °  ,"".(*PublicKey).Params   ¸  <go.string.hdr."ScalarBaseMult"   È  btype.func([]uint8) (*math/big.Int, *math/big.Int)   Ğ  €type.func(*"".PublicKey, []uint8) (*math/big.Int, *math/big.Int)   Ø  <"".(*PublicKey).ScalarBaseMult   à  <"".(*PublicKey).ScalarBaseMult   è  4go.string.hdr."ScalarMult"   ø  type.func(*math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   €  ¼type.func(*"".PublicKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   ˆ  4"".(*PublicKey).ScalarMult     4"".(*PublicKey).ScalarMult   şTgclocalsÂ·33cdeccccebe80329f1fdbee7f5874cb           şTgclocalsÂ·0b86ef39f3fed835f14ba5f4d7c62fa2             şTgclocalsÂ·34eab47d33fa46b254c22cdccfd2dc77                   şTgclocalsÂ·51af24152615272c3d9efc8538f95767                  ş8type..hashfunc."".PrivateKey          0type..hash."".PrivateKey   ş4type..eqfunc."".PrivateKey          ,type..eq."".PrivateKey   ş.type..alg."".PrivateKey              8type..hashfunc."".PrivateKey     4type..eqfunc."".PrivateKey   ş"runtime.gcbits.1f    ş@go.string.hdr."ecdsa.PrivateKey"             8go.string."ecdsa.PrivateKey"   ş8go.string."ecdsa.PrivateKey" (  "ecdsa.PrivateKey  ş"go.string.hdr."D"             go.string."D"   şgo.string."D"   D  şTgclocalsÂ·23e8278e2b69a3a75fa59b23c49ed6ad              şTgclocalsÂ·3f3273e6cb8b40c41344569cdb3bf5df             şTgclocalsÂ·23e8278e2b69a3a75fa59b23c49ed6ad              şTgclocalsÂ·195b7f0f52fd688f87cdc11f42cf3639         ÿ   şTgclocalsÂ·23e8278e2b69a3a75fa59b23c49ed6ad              şTgclocalsÂ·13bdb4aeeaf63de3cc223d640262ea59             şTgclocalsÂ·23e8278e2b69a3a75fa59b23c49ed6ad              şTgclocalsÂ·f73b10702d2d415b96cccabf713539c3      	       şTgclocalsÂ·23e8278e2b69a3a75fa59b23c49ed6ad              şTgclocalsÂ·e5d5edcf53e2c122038779d75a487a60             şTgclocalsÂ·23e8278e2b69a3a75fa59b23c49ed6ad              şTgclocalsÂ·ec7b4b73635f43711b7a725505b4bf2f             şTgclocalsÂ·23e8278e2b69a3a75fa59b23c49ed6ad              şTgclocalsÂ·3f5c1f818fa7055d0400cecd34057162             şTgclocalsÂ·23e8278e2b69a3a75fa59b23c49ed6ad              şTgclocalsÂ·f0c364a62493c61af71404840d80ebfa             şTgclocalsÂ·23e8278e2b69a3a75fa59b23c49ed6ad              şTgclocalsÂ·d98f60bd8519d0c68364b2a1d83af357             şTgclocalsÂ·23e8278e2b69a3a75fa59b23c49ed6ad              şTgclocalsÂ·66fb4c7ebad2133d33206497b98b11d3      
   ?    şTgclocalsÂ·23e8278e2b69a3a75fa59b23c49ed6ad              şTgclocalsÂ·ecc591e57c9cfd5780396a91917d5274             şTgclocalsÂ·23e8278e2b69a3a75fa59b23c49ed6ad              şTgclocalsÂ·4fa86d4dd464bd6bc79c36e165c2cea9         ÿ    şÆgo.string.hdr."func(ecdsa.PrivateKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)"       S      ¾go.string."func(ecdsa.PrivateKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)"   ş¾go.string."func(ecdsa.PrivateKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)" ¨  ¨func(ecdsa.PrivateKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)  şætype.func("".PrivateKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int) ¸  ¸      ü¼IÍ 3                                                                         °  runtime.algarray   (  "runtime.gcbits.01   0  Ægo.string.hdr."func(ecdsa.PrivateKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)"   @  øgo.weak.type.*func("".PrivateKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   P€ ætype.func("".PrivateKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   h¨ ætype.func("".PrivateKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   €  $type."".PrivateKey   ˆ  $type.*math/big.Int     $type.*math/big.Int   ˜  $type.*math/big.Int      $type.*math/big.Int   ¨  $type.*math/big.Int   °  $type.*math/big.Int   şœgo.typelink.func(ecdsa.PrivateKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)	func("".PrivateKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)          ætype.func("".PrivateKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   şgo.string.hdr."func(ecdsa.PrivateKey, *big.Int, *big.Int) (*big.Int, *big.Int)"       ?      –go.string."func(ecdsa.PrivateKey, *big.Int, *big.Int) (*big.Int, *big.Int)"   ş–go.string."func(ecdsa.PrivateKey, *big.Int, *big.Int) (*big.Int, *big.Int)" €  €func(ecdsa.PrivateKey, *big.Int, *big.Int) (*big.Int, *big.Int)  şªtype.func("".PrivateKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int) ¨  ¨      Œÿ‰x 3                                                                 °  runtime.algarray   (  "runtime.gcbits.01   0  go.string.hdr."func(ecdsa.PrivateKey, *big.Int, *big.Int) (*big.Int, *big.Int)"   @  ¼go.weak.type.*func("".PrivateKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   P€ ªtype.func("".PrivateKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   h˜ ªtype.func("".PrivateKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   €  $type."".PrivateKey   ˆ  $type.*math/big.Int     $type.*math/big.Int   ˜  $type.*math/big.Int      $type.*math/big.Int   ş¸go.typelink.func(ecdsa.PrivateKey, *big.Int, *big.Int) (*big.Int, *big.Int)	func("".PrivateKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)          ªtype.func("".PrivateKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   ş~go.string.hdr."func(ecdsa.PrivateKey, *big.Int, *big.Int) bool"       /      vgo.string."func(ecdsa.PrivateKey, *big.Int, *big.Int) bool"   şvgo.string."func(ecdsa.PrivateKey, *big.Int, *big.Int) bool" `  `func(ecdsa.PrivateKey, *big.Int, *big.Int) bool  şvtype.func("".PrivateKey, *math/big.Int, *math/big.Int) bool           "‚ù 3                                                             °  runtime.algarray   (  "runtime.gcbits.01   0  ~go.string.hdr."func(ecdsa.PrivateKey, *big.Int, *big.Int) bool"   @  ˆgo.weak.type.*func("".PrivateKey, *math/big.Int, *math/big.Int) bool   P€ vtype.func("".PrivateKey, *math/big.Int, *math/big.Int) bool   h˜ vtype.func("".PrivateKey, *math/big.Int, *math/big.Int) bool   €  $type."".PrivateKey   ˆ  $type.*math/big.Int     $type.*math/big.Int   ˜  type.bool   şägo.typelink.func(ecdsa.PrivateKey, *big.Int, *big.Int) bool	func("".PrivateKey, *math/big.Int, *math/big.Int) bool          vtype.func("".PrivateKey, *math/big.Int, *math/big.Int) bool   şxgo.string.hdr."func(ecdsa.PrivateKey) *elliptic.CurveParams"       ,      pgo.string."func(ecdsa.PrivateKey) *elliptic.CurveParams"   şpgo.string."func(ecdsa.PrivateKey) *elliptic.CurveParams" `  Zfunc(ecdsa.PrivateKey) *elliptic.CurveParams  şjtype.func("".PrivateKey) *crypto/elliptic.CurveParams         Ó'î 3                                                     °  runtime.algarray   (  "runtime.gcbits.01   0  xgo.string.hdr."func(ecdsa.PrivateKey) *elliptic.CurveParams"   @  |go.weak.type.*func("".PrivateKey) *crypto/elliptic.CurveParams   P€ jtype.func("".PrivateKey) *crypto/elliptic.CurveParams   hˆ jtype.func("".PrivateKey) *crypto/elliptic.CurveParams   €  $type."".PrivateKey   ˆ  Btype.*crypto/elliptic.CurveParams   şÒgo.typelink.func(ecdsa.PrivateKey) *elliptic.CurveParams	func("".PrivateKey) *crypto/elliptic.CurveParams          jtype.func("".PrivateKey) *crypto/elliptic.CurveParams   şˆgo.string.hdr."func(ecdsa.PrivateKey, []uint8) (*big.Int, *big.Int)"       4      €go.string."func(ecdsa.PrivateKey, []uint8) (*big.Int, *big.Int)"   ş€go.string."func(ecdsa.PrivateKey, []uint8) (*big.Int, *big.Int)" p  jfunc(ecdsa.PrivateKey, []uint8) (*big.Int, *big.Int)  ş€type.func("".PrivateKey, []uint8) (*math/big.Int, *math/big.Int)           |Œ¤» 3                                                             °  runtime.algarray   (  "runtime.gcbits.01   0  ˆgo.string.hdr."func(ecdsa.PrivateKey, []uint8) (*big.Int, *big.Int)"   @  ’go.weak.type.*func("".PrivateKey, []uint8) (*math/big.Int, *math/big.Int)   P€ €type.func("".PrivateKey, []uint8) (*math/big.Int, *math/big.Int)   h €type.func("".PrivateKey, []uint8) (*math/big.Int, *math/big.Int)   €  $type."".PrivateKey   ˆ  type.[]uint8     $type.*math/big.Int   ˜  $type.*math/big.Int   şøgo.typelink.func(ecdsa.PrivateKey, []uint8) (*big.Int, *big.Int)	func("".PrivateKey, []uint8) (*math/big.Int, *math/big.Int)          €type.func("".PrivateKey, []uint8) (*math/big.Int, *math/big.Int)   ş°go.string.hdr."func(ecdsa.PrivateKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)"       H      ¨go.string."func(ecdsa.PrivateKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)"   ş¨go.string."func(ecdsa.PrivateKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)" ˜  ’func(ecdsa.PrivateKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)  ş¼type.func("".PrivateKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int) °  °      ¥ÑX 3                                                                     °  runtime.algarray   (  "runtime.gcbits.01   0  °go.string.hdr."func(ecdsa.PrivateKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)"   @  Îgo.weak.type.*func("".PrivateKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   P€ ¼type.func("".PrivateKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   h  ¼type.func("".PrivateKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   €  $type."".PrivateKey   ˆ  $type.*math/big.Int     $type.*math/big.Int   ˜  type.[]uint8      $type.*math/big.Int   ¨  $type.*math/big.Int   şÜgo.typelink.func(ecdsa.PrivateKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)	func("".PrivateKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)          ¼type.func("".PrivateKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   ş4go.string.hdr."PrivateKey"       
      ,go.string."PrivateKey"   ş,go.string."PrivateKey"   PrivateKey  ş$type."".PrivateKey  ø  ø      A;!–                                                                                                                                                                                                                                        T   .type..alg."".PrivateKey   (  "runtime.gcbits.1f   0  @go.string.hdr."ecdsa.PrivateKey"   @  &type.*"".PrivateKey   H` $type."".PrivateKey   p  "type."".PublicKey   ˆ  "go.string.hdr."D"   ˜  $type.*math/big.Int   8° $type."".PrivateKey   °  4go.string.hdr."PrivateKey"   ¸  "go.importpath."".   ÀØ $type."".PrivateKey   Ø  &go.string.hdr."Add"   è  Ètype.func(*math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   ğ  ætype.func("".PrivateKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   ø  ("".(*PrivateKey).Add   €  """.PrivateKey.Add   ˆ  ,go.string.hdr."Double"   ˜  Œtype.func(*math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)      ªtype.func("".PrivateKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   ¨  ."".(*PrivateKey).Double   °  ("".PrivateKey.Double   ¸  2go.string.hdr."IsOnCurve"   È  Xtype.func(*math/big.Int, *math/big.Int) bool   Ğ  vtype.func("".PrivateKey, *math/big.Int, *math/big.Int) bool   Ø  4"".(*PrivateKey).IsOnCurve   à  ."".PrivateKey.IsOnCurve   è  ,go.string.hdr."Params"   ø  Ptype.func() *crypto/elliptic.CurveParams   €  jtype.func("".PrivateKey) *crypto/elliptic.CurveParams   ˆ  ."".(*PrivateKey).Params     ("".PrivateKey.Params   ˜  <go.string.hdr."ScalarBaseMult"   ¨  btype.func([]uint8) (*math/big.Int, *math/big.Int)   °  €type.func("".PrivateKey, []uint8) (*math/big.Int, *math/big.Int)   ¸  >"".(*PrivateKey).ScalarBaseMult   À  8"".PrivateKey.ScalarBaseMult   È  4go.string.hdr."ScalarMult"   Ø  type.func(*math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   à  ¼type.func("".PrivateKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   è  6"".(*PrivateKey).ScalarMult   ğ  0"".PrivateKey.ScalarMult   şBgo.string.hdr."*ecdsa.PrivateKey"             :go.string."*ecdsa.PrivateKey"   ş:go.string."*ecdsa.PrivateKey" (  $*ecdsa.PrivateKey  şÈgo.string.hdr."func(*ecdsa.PrivateKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)"       T      Àgo.string."func(*ecdsa.PrivateKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)"   şÀgo.string."func(*ecdsa.PrivateKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)" °  ªfunc(*ecdsa.PrivateKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)  şètype.func(*"".PrivateKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int) ¸  ¸      w©Kı 3                                                                         °  runtime.algarray   (  "runtime.gcbits.01   0  Ègo.string.hdr."func(*ecdsa.PrivateKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)"   @  úgo.weak.type.*func(*"".PrivateKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   P€ ètype.func(*"".PrivateKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   h¨ ètype.func(*"".PrivateKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   €  &type.*"".PrivateKey   ˆ  $type.*math/big.Int     $type.*math/big.Int   ˜  $type.*math/big.Int      $type.*math/big.Int   ¨  $type.*math/big.Int   °  $type.*math/big.Int   ş go.typelink.func(*ecdsa.PrivateKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)	func(*"".PrivateKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)          ètype.func(*"".PrivateKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   ş go.string.hdr."func(*ecdsa.PrivateKey, *big.Int, *big.Int) (*big.Int, *big.Int)"       @      ˜go.string."func(*ecdsa.PrivateKey, *big.Int, *big.Int) (*big.Int, *big.Int)"   ş˜go.string."func(*ecdsa.PrivateKey, *big.Int, *big.Int) (*big.Int, *big.Int)" ˆ  ‚func(*ecdsa.PrivateKey, *big.Int, *big.Int) (*big.Int, *big.Int)  ş¬type.func(*"".PrivateKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int) ¨  ¨      ;šN 3                                                                 °  runtime.algarray   (  "runtime.gcbits.01   0   go.string.hdr."func(*ecdsa.PrivateKey, *big.Int, *big.Int) (*big.Int, *big.Int)"   @  ¾go.weak.type.*func(*"".PrivateKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   P€ ¬type.func(*"".PrivateKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   h˜ ¬type.func(*"".PrivateKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   €  &type.*"".PrivateKey   ˆ  $type.*math/big.Int     $type.*math/big.Int   ˜  $type.*math/big.Int      $type.*math/big.Int   ş¼go.typelink.func(*ecdsa.PrivateKey, *big.Int, *big.Int) (*big.Int, *big.Int)	func(*"".PrivateKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)          ¬type.func(*"".PrivateKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   ş€go.string.hdr."func(*ecdsa.PrivateKey, *big.Int, *big.Int) bool"       0      xgo.string."func(*ecdsa.PrivateKey, *big.Int, *big.Int) bool"   şxgo.string."func(*ecdsa.PrivateKey, *big.Int, *big.Int) bool" h  bfunc(*ecdsa.PrivateKey, *big.Int, *big.Int) bool  şxtype.func(*"".PrivateKey, *math/big.Int, *math/big.Int) bool           ^IŒ? 3                                                             °  runtime.algarray   (  "runtime.gcbits.01   0  €go.string.hdr."func(*ecdsa.PrivateKey, *big.Int, *big.Int) bool"   @  Šgo.weak.type.*func(*"".PrivateKey, *math/big.Int, *math/big.Int) bool   P€ xtype.func(*"".PrivateKey, *math/big.Int, *math/big.Int) bool   h˜ xtype.func(*"".PrivateKey, *math/big.Int, *math/big.Int) bool   €  &type.*"".PrivateKey   ˆ  $type.*math/big.Int     $type.*math/big.Int   ˜  type.bool   şègo.typelink.func(*ecdsa.PrivateKey, *big.Int, *big.Int) bool	func(*"".PrivateKey, *math/big.Int, *math/big.Int) bool          xtype.func(*"".PrivateKey, *math/big.Int, *math/big.Int) bool   şzgo.string.hdr."func(*ecdsa.PrivateKey) *elliptic.CurveParams"       -      rgo.string."func(*ecdsa.PrivateKey) *elliptic.CurveParams"   şrgo.string."func(*ecdsa.PrivateKey) *elliptic.CurveParams" `  \func(*ecdsa.PrivateKey) *elliptic.CurveParams  şltype.func(*"".PrivateKey) *crypto/elliptic.CurveParams         “â 3                                                     °  runtime.algarray   (  "runtime.gcbits.01   0  zgo.string.hdr."func(*ecdsa.PrivateKey) *elliptic.CurveParams"   @  ~go.weak.type.*func(*"".PrivateKey) *crypto/elliptic.CurveParams   P€ ltype.func(*"".PrivateKey) *crypto/elliptic.CurveParams   hˆ ltype.func(*"".PrivateKey) *crypto/elliptic.CurveParams   €  &type.*"".PrivateKey   ˆ  Btype.*crypto/elliptic.CurveParams   şÖgo.typelink.func(*ecdsa.PrivateKey) *elliptic.CurveParams	func(*"".PrivateKey) *crypto/elliptic.CurveParams          ltype.func(*"".PrivateKey) *crypto/elliptic.CurveParams   şpgo.string.hdr."func(*ecdsa.PrivateKey) crypto.PublicKey"       (      hgo.string."func(*ecdsa.PrivateKey) crypto.PublicKey"   şhgo.string."func(*ecdsa.PrivateKey) crypto.PublicKey" X  Rfunc(*ecdsa.PrivateKey) crypto.PublicKey  şTtype.func(*"".PrivateKey) crypto.PublicKey         5­EK 3                                                     °  runtime.algarray   (  "runtime.gcbits.01   0  pgo.string.hdr."func(*ecdsa.PrivateKey) crypto.PublicKey"   @  fgo.weak.type.*func(*"".PrivateKey) crypto.PublicKey   P€ Ttype.func(*"".PrivateKey) crypto.PublicKey   hˆ Ttype.func(*"".PrivateKey) crypto.PublicKey   €  &type.*"".PrivateKey   ˆ  *type.crypto.PublicKey   ş´go.typelink.func(*ecdsa.PrivateKey) crypto.PublicKey	func(*"".PrivateKey) crypto.PublicKey          Ttype.func(*"".PrivateKey) crypto.PublicKey   şŠgo.string.hdr."func(*ecdsa.PrivateKey, []uint8) (*big.Int, *big.Int)"       5      ‚go.string."func(*ecdsa.PrivateKey, []uint8) (*big.Int, *big.Int)"   ş‚go.string."func(*ecdsa.PrivateKey, []uint8) (*big.Int, *big.Int)" p  lfunc(*ecdsa.PrivateKey, []uint8) (*big.Int, *big.Int)  ş‚type.func(*"".PrivateKey, []uint8) (*math/big.Int, *math/big.Int)           ßÒ 3                                                             °  runtime.algarray   (  "runtime.gcbits.01   0  Šgo.string.hdr."func(*ecdsa.PrivateKey, []uint8) (*big.Int, *big.Int)"   @  ”go.weak.type.*func(*"".PrivateKey, []uint8) (*math/big.Int, *math/big.Int)   P€ ‚type.func(*"".PrivateKey, []uint8) (*math/big.Int, *math/big.Int)   h ‚type.func(*"".PrivateKey, []uint8) (*math/big.Int, *math/big.Int)   €  &type.*"".PrivateKey   ˆ  type.[]uint8     $type.*math/big.Int   ˜  $type.*math/big.Int   şügo.typelink.func(*ecdsa.PrivateKey, []uint8) (*big.Int, *big.Int)	func(*"".PrivateKey, []uint8) (*math/big.Int, *math/big.Int)          ‚type.func(*"".PrivateKey, []uint8) (*math/big.Int, *math/big.Int)   ş²go.string.hdr."func(*ecdsa.PrivateKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)"       I      ªgo.string."func(*ecdsa.PrivateKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)"   şªgo.string."func(*ecdsa.PrivateKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)" ˜  ”func(*ecdsa.PrivateKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)  ş¾type.func(*"".PrivateKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int) °  °      ò	 3                                                                     °  runtime.algarray   (  "runtime.gcbits.01   0  ²go.string.hdr."func(*ecdsa.PrivateKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)"   @  Ğgo.weak.type.*func(*"".PrivateKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   P€ ¾type.func(*"".PrivateKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   h  ¾type.func(*"".PrivateKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   €  &type.*"".PrivateKey   ˆ  $type.*math/big.Int     $type.*math/big.Int   ˜  type.[]uint8      $type.*math/big.Int   ¨  $type.*math/big.Int   şàgo.typelink.func(*ecdsa.PrivateKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)	func(*"".PrivateKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)          ¾type.func(*"".PrivateKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   ş¾go.string.hdr."func(*ecdsa.PrivateKey, io.Reader, []uint8, crypto.SignerOpts) ([]uint8, error)"       O      ¶go.string."func(*ecdsa.PrivateKey, io.Reader, []uint8, crypto.SignerOpts) ([]uint8, error)"   ş¶go.string."func(*ecdsa.PrivateKey, io.Reader, []uint8, crypto.SignerOpts) ([]uint8, error)"     func(*ecdsa.PrivateKey, io.Reader, []uint8, crypto.SignerOpts) ([]uint8, error)  ş¢type.func(*"".PrivateKey, io.Reader, []uint8, crypto.SignerOpts) ([]uint8, error) °  °      ¥"Ó 3                                                                     °  runtime.algarray   (  "runtime.gcbits.01   0  ¾go.string.hdr."func(*ecdsa.PrivateKey, io.Reader, []uint8, crypto.SignerOpts) ([]uint8, error)"   @  ´go.weak.type.*func(*"".PrivateKey, io.Reader, []uint8, crypto.SignerOpts) ([]uint8, error)   P€ ¢type.func(*"".PrivateKey, io.Reader, []uint8, crypto.SignerOpts) ([]uint8, error)   h  ¢type.func(*"".PrivateKey, io.Reader, []uint8, crypto.SignerOpts) ([]uint8, error)   €  &type.*"".PrivateKey   ˆ  type.io.Reader     type.[]uint8   ˜  ,type.crypto.SignerOpts      type.[]uint8   ¨  type.error   şĞgo.typelink.func(*ecdsa.PrivateKey, io.Reader, []uint8, crypto.SignerOpts) ([]uint8, error)	func(*"".PrivateKey, io.Reader, []uint8, crypto.SignerOpts) ([]uint8, error)          ¢type.func(*"".PrivateKey, io.Reader, []uint8, crypto.SignerOpts) ([]uint8, error)   ş,go.string.hdr."Public"             $go.string."Public"   ş$go.string."Public"   Public  şNgo.string.hdr."func() crypto.PublicKey"             Fgo.string."func() crypto.PublicKey"   şFgo.string."func() crypto.PublicKey" 0  0func() crypto.PublicKey  ş8type.func() crypto.PublicKey ˆ  ˆ      T¿, 3                                                   °  runtime.algarray   (  "runtime.gcbits.01   0  Ngo.string.hdr."func() crypto.PublicKey"   @  Jgo.weak.type.*func() crypto.PublicKey   P€ 8type.func() crypto.PublicKey   h€ 8type.func() crypto.PublicKey   €  *type.crypto.PublicKey   şvgo.typelink.func() crypto.PublicKey	func() crypto.PublicKey          8type.func() crypto.PublicKey   ş(go.string.hdr."Sign"              go.string."Sign"   ş go.string."Sign"   
Sign  ş˜go.string.hdr."func(io.Reader, []uint8, crypto.SignerOpts) ([]uint8, error)"       <      go.string."func(io.Reader, []uint8, crypto.SignerOpts) ([]uint8, error)"   şgo.string."func(io.Reader, []uint8, crypto.SignerOpts) ([]uint8, error)" €  zfunc(io.Reader, []uint8, crypto.SignerOpts) ([]uint8, error)  ş‚type.func(io.Reader, []uint8, crypto.SignerOpts) ([]uint8, error) ¨  ¨      —@` 3                                                                 °  runtime.algarray   (  "runtime.gcbits.01   0  ˜go.string.hdr."func(io.Reader, []uint8, crypto.SignerOpts) ([]uint8, error)"   @  ”go.weak.type.*func(io.Reader, []uint8, crypto.SignerOpts) ([]uint8, error)   P€ ‚type.func(io.Reader, []uint8, crypto.SignerOpts) ([]uint8, error)   h˜ ‚type.func(io.Reader, []uint8, crypto.SignerOpts) ([]uint8, error)   €  type.io.Reader   ˆ  type.[]uint8     ,type.crypto.SignerOpts   ˜  type.[]uint8      type.error   şŠgo.typelink.func(io.Reader, []uint8, crypto.SignerOpts) ([]uint8, error)	func(io.Reader, []uint8, crypto.SignerOpts) ([]uint8, error)          ‚type.func(io.Reader, []uint8, crypto.SignerOpts) ([]uint8, error)   ş&type.*"".PrivateKey  ø  ø      Ñƒ¿Ê 6                                                                                                                                                                                                                                          ^ @  runtime.algarray   (  "runtime.gcbits.01   0  Bgo.string.hdr."*ecdsa.PrivateKey"   @  8go.weak.type.**"".PrivateKey   H  $type."".PrivateKey   8P &type.*"".PrivateKey   `x &type.*"".PrivateKey   x  &go.string.hdr."Add"   ˆ  Ètype.func(*math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)     ètype.func(*"".PrivateKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   ˜  ("".(*PrivateKey).Add      ("".(*PrivateKey).Add   ¨  ,go.string.hdr."Double"   ¸  Œtype.func(*math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   À  ¬type.func(*"".PrivateKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   È  ."".(*PrivateKey).Double   Ğ  ."".(*PrivateKey).Double   Ø  2go.string.hdr."IsOnCurve"   è  Xtype.func(*math/big.Int, *math/big.Int) bool   ğ  xtype.func(*"".PrivateKey, *math/big.Int, *math/big.Int) bool   ø  4"".(*PrivateKey).IsOnCurve   €  4"".(*PrivateKey).IsOnCurve   ˆ  ,go.string.hdr."Params"   ˜  Ptype.func() *crypto/elliptic.CurveParams      ltype.func(*"".PrivateKey) *crypto/elliptic.CurveParams   ¨  ."".(*PrivateKey).Params   °  ."".(*PrivateKey).Params   ¸  ,go.string.hdr."Public"   È  8type.func() crypto.PublicKey   Ğ  Ttype.func(*"".PrivateKey) crypto.PublicKey   Ø  ."".(*PrivateKey).Public   à  ."".(*PrivateKey).Public   è  <go.string.hdr."ScalarBaseMult"   ø  btype.func([]uint8) (*math/big.Int, *math/big.Int)   €  ‚type.func(*"".PrivateKey, []uint8) (*math/big.Int, *math/big.Int)   ˆ  >"".(*PrivateKey).ScalarBaseMult     >"".(*PrivateKey).ScalarBaseMult   ˜  4go.string.hdr."ScalarMult"   ¨  type.func(*math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   °  ¾type.func(*"".PrivateKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   ¸  6"".(*PrivateKey).ScalarMult   À  6"".(*PrivateKey).ScalarMult   È  (go.string.hdr."Sign"   Ø  ‚type.func(io.Reader, []uint8, crypto.SignerOpts) ([]uint8, error)   à  ¢type.func(*"".PrivateKey, io.Reader, []uint8, crypto.SignerOpts) ([]uint8, error)   è  *"".(*PrivateKey).Sign   ğ  *"".(*PrivateKey).Sign   şJgo.string.hdr."*ecdsa.ecdsaSignature"             Bgo.string."*ecdsa.ecdsaSignature"   şBgo.string."*ecdsa.ecdsaSignature" 0  ,*ecdsa.ecdsaSignature  ş.type.*"".ecdsaSignature  P  P      ©
ÛK 6                        
 @  runtime.algarray   (  "runtime.gcbits.01   0  Jgo.string.hdr."*ecdsa.ecdsaSignature"   @  @go.weak.type.**"".ecdsaSignature   H  ,type."".ecdsaSignature   ş"runtime.gcbits.03    şHgo.string.hdr."ecdsa.ecdsaSignature"             @go.string."ecdsa.ecdsaSignature"   ş@go.string."ecdsa.ecdsaSignature" 0  *ecdsa.ecdsaSignature  ş"go.string.hdr."R"             go.string."R"   şgo.string."R"   R  ş"go.string.hdr."S"             go.string."S"   şgo.string."S"   S  ş<go.string.hdr."ecdsaSignature"             4go.string."ecdsaSignature"   ş4go.string."ecdsaSignature"    ecdsaSignature  ş,type."".ecdsaSignature  Ø  Ø      DÁ)e                                                                                           P  runtime.algarray   (  "runtime.gcbits.03   0  Hgo.string.hdr."ecdsa.ecdsaSignature"   @  .type.*"".ecdsaSignature   H` ,type."".ecdsaSignature   `  "go.string.hdr."R"   p  $type.*math/big.Int   ˆ  "go.string.hdr."S"   ˜  $type.*math/big.Int   8° ,type."".ecdsaSignature   °  <go.string.hdr."ecdsaSignature"   ¸  "go.importpath."".   ÀØ ,type."".ecdsaSignature   ş0go.string.hdr."ecdsa.zr"             (go.string."ecdsa.zr"   ş(go.string."ecdsa.zr"   ecdsa.zr  ş$go.string.hdr."zr"             go.string."zr"   şgo.string."zr"   zr  ştype."".zr  °  °      WÒ~Ê                                                                        ğ  runtime.algarray   (  "runtime.gcbits.03   0  0go.string.hdr."ecdsa.zr"   @  type.*"".zr   H` type."".zr   p  type.io.Reader   8ˆ type."".zr   ˆ  $go.string.hdr."zr"     "go.importpath."".   ˜° type."".zr   ş2go.string.hdr."*ecdsa.zr"       	      *go.string."*ecdsa.zr"   ş*go.string."*ecdsa.zr"   *ecdsa.zr  şjgo.string.hdr."func(*ecdsa.zr, []uint8) (int, error)"       %      bgo.string."func(*ecdsa.zr, []uint8) (int, error)"   şbgo.string."func(*ecdsa.zr, []uint8) (int, error)" P  Lfunc(*ecdsa.zr, []uint8) (int, error)  şNtype.func(*"".zr, []uint8) (int, error)           FwW 3                                                             °  runtime.algarray   (  "runtime.gcbits.01   0  jgo.string.hdr."func(*ecdsa.zr, []uint8) (int, error)"   @  `go.weak.type.*func(*"".zr, []uint8) (int, error)   P€ Ntype.func(*"".zr, []uint8) (int, error)   h Ntype.func(*"".zr, []uint8) (int, error)   €  type.*"".zr   ˆ  type.[]uint8     type.int   ˜  type.error   ş¨go.typelink.func(*ecdsa.zr, []uint8) (int, error)	func(*"".zr, []uint8) (int, error)          Ntype.func(*"".zr, []uint8) (int, error)   ş(go.string.hdr."Read"              go.string."Read"   ş go.string."Read"   
Read  şTgo.string.hdr."func([]uint8) (int, error)"             Lgo.string."func([]uint8) (int, error)"   şLgo.string."func([]uint8) (int, error)" 8  6func([]uint8) (int, error)  ş>type.func([]uint8) (int, error) ˜  ˜      „N4P 3                                                         °  runtime.algarray   (  "runtime.gcbits.01   0  Tgo.string.hdr."func([]uint8) (int, error)"   @  Pgo.weak.type.*func([]uint8) (int, error)   P€ >type.func([]uint8) (int, error)   hˆ >type.func([]uint8) (int, error)   €  type.[]uint8   ˆ  type.int     type.error   ş‚go.typelink.func([]uint8) (int, error)	func([]uint8) (int, error)          >type.func([]uint8) (int, error)   ştype.*"".zr  ¨  ¨      €–¾4 6                                                                   @  runtime.algarray   (  "runtime.gcbits.01   0  2go.string.hdr."*ecdsa.zr"   @  (go.weak.type.**"".zr   H  type."".zr   8P type.*"".zr   `x type.*"".zr   x  (go.string.hdr."Read"   ˆ  >type.func([]uint8) (int, error)     Ntype.func(*"".zr, []uint8) (int, error)   ˜  "".(*zr).Read      "".(*zr).Read   şTgclocalsÂ·33cdeccccebe80329f1fdbee7f5874cb           şTgclocalsÂ·e5d5edcf53e2c122038779d75a487a60             şNgo.string.hdr."func(*big.Int) *big.Int"             Fgo.string."func(*big.Int) *big.Int"   şFgo.string."func(*big.Int) *big.Int" 0  0func(*big.Int) *big.Int  şLtype.func(*math/big.Int) *math/big.Int         ¹ÌÅ 3                                                     °  runtime.algarray   (  "runtime.gcbits.01   0  Ngo.string.hdr."func(*big.Int) *big.Int"   @  ^go.weak.type.*func(*math/big.Int) *math/big.Int   P€ Ltype.func(*math/big.Int) *math/big.Int   hˆ Ltype.func(*math/big.Int) *math/big.Int   €  $type.*math/big.Int   ˆ  $type.*math/big.Int   şŠgo.typelink.func(*big.Int) *big.Int	func(*math/big.Int) *math/big.Int          Ltype.func(*math/big.Int) *math/big.Int   şBgo.string.hdr."*ecdsa.invertible"             :go.string."*ecdsa.invertible"   ş:go.string."*ecdsa.invertible" (  $*ecdsa.invertible  ş&type.*"".invertible  P  P      uÕFı 6                        
 @  runtime.algarray   (  "runtime.gcbits.01   0  Bgo.string.hdr."*ecdsa.invertible"   @  8go.weak.type.**"".invertible   H  $type."".invertible   ş@go.string.hdr."ecdsa.invertible"             8go.string."ecdsa.invertible"   ş8go.string."ecdsa.invertible" (  "ecdsa.invertible  ş.go.string.hdr."Inverse"             &go.string."Inverse"   ş&go.string."Inverse"   Inverse  ş4go.string.hdr."invertible"       
      ,go.string."invertible"   ş,go.string."invertible"   invertible  ş$type."".invertible            hüt                                                                ğ  runtime.algarray   (  "runtime.gcbits.03   0  @go.string.hdr."ecdsa.invertible"   @  &type.*"".invertible   H` $type."".invertible   `  .go.string.hdr."Inverse"   p  Ltype.func(*math/big.Int) *math/big.Int   8x $type."".invertible   x  4go.string.hdr."invertible"   €  "go.importpath."".   ˆ  $type."".invertible   ş type..hashfunc32              ,runtime.memhash_varlen   ştype..eqfunc32              .runtime.memequal_varlen   ştype..alg32               type..hashfunc32     type..eqfunc32   şruntime.gcbits.      ş2go.string.hdr."[32]uint8"       	      *go.string."[32]uint8"   ş*go.string."[32]uint8"   [32]uint8  ştype.[32]uint8 `  `        œYÿ¨ ‘                                   type..alg32   (  runtime.gcbits.   0  2go.string.hdr."[32]uint8"   @  .go.weak.type.*[32]uint8   H  type.uint8   P  type.[]uint8   ş>go.typelink.[32]uint8	[32]uint8          type.[32]uint8   şTgclocalsÂ·33cdeccccebe80329f1fdbee7f5874cb           şTgclocalsÂ·3a4457348598b5a434e53329773b7b05         Ÿ    şgo.string.hdr."func(*big.Int, *big.Int, []uint8, []uint8) (*big.Int, *big.Int)"       ?      –go.string."func(*big.Int, *big.Int, []uint8, []uint8) (*big.Int, *big.Int)"   ş–go.string."func(*big.Int, *big.Int, []uint8, []uint8) (*big.Int, *big.Int)" €  €func(*big.Int, *big.Int, []uint8, []uint8) (*big.Int, *big.Int)  ş°type.func(*math/big.Int, *math/big.Int, []uint8, []uint8) (*math/big.Int, *math/big.Int) °  °      }‘ç' 3                                                                     °  runtime.algarray   (  "runtime.gcbits.01   0  go.string.hdr."func(*big.Int, *big.Int, []uint8, []uint8) (*big.Int, *big.Int)"   @  Âgo.weak.type.*func(*math/big.Int, *math/big.Int, []uint8, []uint8) (*math/big.Int, *math/big.Int)   P€ °type.func(*math/big.Int, *math/big.Int, []uint8, []uint8) (*math/big.Int, *math/big.Int)   h  °type.func(*math/big.Int, *math/big.Int, []uint8, []uint8) (*math/big.Int, *math/big.Int)   €  $type.*math/big.Int   ˆ  $type.*math/big.Int     type.[]uint8   ˜  type.[]uint8      $type.*math/big.Int   ¨  $type.*math/big.Int   ş¾go.typelink.func(*big.Int, *big.Int, []uint8, []uint8) (*big.Int, *big.Int)	func(*math/big.Int, *math/big.Int, []uint8, []uint8) (*math/big.Int, *math/big.Int)          °type.func(*math/big.Int, *math/big.Int, []uint8, []uint8) (*math/big.Int, *math/big.Int)   şFgo.string.hdr."*ecdsa.combinedMult"             >go.string."*ecdsa.combinedMult"   ş>go.string."*ecdsa.combinedMult" (  (*ecdsa.combinedMult  ş*type.*"".combinedMult  P  P      ƒ5 6                        
 @  runtime.algarray   (  "runtime.gcbits.01   0  Fgo.string.hdr."*ecdsa.combinedMult"   @  <go.weak.type.**"".combinedMult   H  (type."".combinedMult   şDgo.string.hdr."ecdsa.combinedMult"             <go.string."ecdsa.combinedMult"   ş<go.string."ecdsa.combinedMult" (  &ecdsa.combinedMult  ş8go.string.hdr."CombinedMult"             0go.string."CombinedMult"   ş0go.string."CombinedMult"    CombinedMult  ş8go.string.hdr."combinedMult"             0go.string."combinedMult"   ş0go.string."combinedMult"    combinedMult  ş(type."".combinedMult            !ÑI£                                                                ğ  runtime.algarray   (  "runtime.gcbits.03   0  Dgo.string.hdr."ecdsa.combinedMult"   @  *type.*"".combinedMult   H` (type."".combinedMult   `  8go.string.hdr."CombinedMult"   p  °type.func(*math/big.Int, *math/big.Int, []uint8, []uint8) (*math/big.Int, *math/big.Int)   8x (type."".combinedMult   x  8go.string.hdr."combinedMult"   €  "go.importpath."".   ˆ  (type."".combinedMult   ş,go.string.hdr."crypto"             $go.string."crypto"   ş$go.string."crypto"   crypto  ş*go.importpath.crypto.             $go.string."crypto"   ş$go.string.hdr."io"             go.string."io"   şgo.string."io"   io  ş"go.importpath.io.             go.string."io"   ş4go.string.hdr."crypto/aes"       
      ,go.string."crypto/aes"   ş,go.string."crypto/aes"   crypto/aes  ş2go.importpath.crypto/aes.       
      ,go.string."crypto/aes"   ş:go.string.hdr."crypto/cipher"             2go.string."crypto/cipher"   ş2go.string."crypto/cipher"    crypto/cipher  ş8go.importpath.crypto/cipher.             2go.string."crypto/cipher"   ş>go.string.hdr."crypto/elliptic"             6go.string."crypto/elliptic"   ş6go.string."crypto/elliptic"     crypto/elliptic  ş<go.importpath.crypto/elliptic.             6go.string."crypto/elliptic"   ş0go.string.hdr."math/big"             (go.string."math/big"   ş(go.string."math/big"   math/big  ş.go.importpath.math/big.             (go.string."math/big"   ş:go.string.hdr."crypto/sha512"             2go.string."crypto/sha512"   ş2go.string."crypto/sha512"    crypto/sha512  ş8go.importpath.crypto/sha512.             2go.string."crypto/sha512"   ş:go.string.hdr."encoding/asn1"             2go.string."encoding/asn1"   ş2go.string."encoding/asn1"    encoding/asn1  ş8go.importpath.encoding/asn1.             2go.string."encoding/asn1"   ş4type..hash."".PublicKeyÂ·f          .type..hash."".PublicKey   ş0type..eq."".PublicKeyÂ·f          *type..eq."".PublicKey   ş,"".(*PublicKey).AddÂ·f          &"".(*PublicKey).Add   ş&"".PublicKey.AddÂ·f           "".PublicKey.Add   ş2"".(*PublicKey).DoubleÂ·f          ,"".(*PublicKey).Double   ş,"".PublicKey.DoubleÂ·f          &"".PublicKey.Double   ş8"".(*PublicKey).IsOnCurveÂ·f          2"".(*PublicKey).IsOnCurve   ş2"".PublicKey.IsOnCurveÂ·f          ,"".PublicKey.IsOnCurve   ş2"".(*PublicKey).ParamsÂ·f          ,"".(*PublicKey).Params   ş,"".PublicKey.ParamsÂ·f          &"".PublicKey.Params   şB"".(*PublicKey).ScalarBaseMultÂ·f          <"".(*PublicKey).ScalarBaseMult   ş<"".PublicKey.ScalarBaseMultÂ·f          6"".PublicKey.ScalarBaseMult   ş:"".(*PublicKey).ScalarMultÂ·f          4"".(*PublicKey).ScalarMult   ş4"".PublicKey.ScalarMultÂ·f          ."".PublicKey.ScalarMult   ş6type..hash."".PrivateKeyÂ·f          0type..hash."".PrivateKey   ş2type..eq."".PrivateKeyÂ·f          ,type..eq."".PrivateKey   ş."".(*PrivateKey).AddÂ·f          ("".(*PrivateKey).Add   ş("".PrivateKey.AddÂ·f          """.PrivateKey.Add   ş4"".(*PrivateKey).DoubleÂ·f          ."".(*PrivateKey).Double   ş."".PrivateKey.DoubleÂ·f          ("".PrivateKey.Double   ş:"".(*PrivateKey).IsOnCurveÂ·f          4"".(*PrivateKey).IsOnCurve   ş4"".PrivateKey.IsOnCurveÂ·f          ."".PrivateKey.IsOnCurve   ş4"".(*PrivateKey).ParamsÂ·f          ."".(*PrivateKey).Params   ş."".PrivateKey.ParamsÂ·f          ("".PrivateKey.Params   şD"".(*PrivateKey).ScalarBaseMultÂ·f          >"".(*PrivateKey).ScalarBaseMult   ş>"".PrivateKey.ScalarBaseMultÂ·f          8"".PrivateKey.ScalarBaseMult   ş<"".(*PrivateKey).ScalarMultÂ·f          6"".(*PrivateKey).ScalarMult   ş6"".PrivateKey.ScalarMultÂ·f          0"".PrivateKey.ScalarMult   ş0"".invertible.InverseÂ·f          *"".invertible.Inverse   ş>"".combinedMult.CombinedMultÂ·f          8"".combinedMult.CombinedMult   ÿÿgo13ld 